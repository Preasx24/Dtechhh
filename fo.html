<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gutenberg Library â€” Paged Reader + Read Later</title>
<style>
  :root{
    --accent:#8b6b4c;
    --accent-light:#d4c4b5;
    --accent-dark:#6d533c;
    --text:#2c1810;
    --text-light:#5a4a3a;
    --muted:#9e8e7e;
    --background:#f9f5f1;
    --card-bg:#ffffff;
    --book-font: "Georgia","Times New Roman", serif;
    --reader-font-size: 9px; /* Reduced font size */
    --page-words: 500;
  }

  html,body{
    height:100%;
    margin:0;
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    color:var(--text);
    background:var(--background);
    line-height:1.5;
  }

  .topbar{
    background:var(--card-bg);
    padding:16px 24px;
    border-bottom:1px solid var(--accent-light);
    display:flex;
    align-items:center;
    justify-content:space-between;
    position:sticky;
    top:0;
    z-index:30;
    box-shadow:0 2px 10px rgba(0,0,0,0.05);
  }

  .brand{
    font-weight:700;
    font-size:22px;
    color:var(--accent-dark);
    display:flex;
    align-items:center;
    gap:10px;
  }

  .brand-icon{
    font-size:24px;
  }

  .tabs{
    display:flex;
    gap:4px;
    background:var(--accent-light);
    padding:4px;
    border-radius:12px;
  }

  .tab{
    padding:10px 20px;
    border-radius:8px;
    background:transparent;
    color:var(--text-light);
    cursor:pointer;
    font-weight:500;
    transition:all 0.2s ease;
  }

  .tab.active{
    background:var(--accent-dark);
    color:#fff;
  }

  .search-row{
    display:flex;
    gap:12px;
    align-items:center;
    padding:20px 24px;
    background:var(--card-bg);
    border-bottom:1px solid var(--accent-light);
  }

  #searchInput{
    padding:12px 16px;
    border-radius:10px;
    border:1px solid var(--accent-light);
    flex:1;
    max-width:500px;
    font-size:16px;
    background:var(--background);
    transition:all 0.2s ease;
  }

  #searchInput:focus{
    outline:none;
    border-color:var(--accent);
    box-shadow:0 0 0 3px rgba(139, 107, 76, 0.1);
  }

  #genreFilter{
    padding:12px 16px;
    border-radius:10px;
    border:1px solid var(--accent-light);
    background:var(--background);
    font-size:16px;
    min-width:180px;
  }

  .layout{
    max-width:1200px;
    margin:24px auto;
    padding:0 20px;
  }

  .stats{
    color:var(--muted);
    margin:12px 0 20px;
    font-size:15px;
  }

  .books-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(240px,1fr));
    gap:20px;
  }

  .book-card{
    background:var(--card-bg);
    border-radius:12px;
    padding:16px;
    box-shadow:0 4px 12px rgba(0,0,0,0.06);
    display:flex;
    flex-direction:column;
    gap:12px;
    min-height:260px;
    transition:all 0.3s ease;
    border:1px solid transparent;
    cursor:pointer;
  }

  .book-card:hover{
    transform:translateY(-5px);
    box-shadow:0 8px 20px rgba(0,0,0,0.1);
    border-color:var(--accent-light);
  }

  .cover-wrap{
    height:160px;
    border-radius:8px;
    overflow:hidden;
    background:#f3f3f3;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    box-shadow:0 4px 8px rgba(0,0,0,0.1);
  }

  .cover-wrap img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }

  .cover-placeholder{
    padding:8px;
    text-align:center;
    font-weight:700;
    color:#333;
  }

  .book-title{
    font-weight:700;
    font-size:16px;
    line-height:1.3;
    color:var(--text);
  }

  .book-author{
    color:var(--muted);
    font-size:14px;
  }

  .book-genre{
    color:var(--accent);
    font-size:12px;
    font-weight:500;
    margin-top:4px;
  }

  .card-row{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:auto;
  }

  .btn{
    padding:10px 14px;
    border-radius:8px;
    border:none;
    background:var(--accent);
    color:#fff;
    cursor:pointer;
    font-weight:500;
    transition:all 0.2s ease;
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:6px;
  }

  .btn:hover{
    background:var(--accent-dark);
    transform:translateY(-1px);
  }

  .btn.secondary{
    background:var(--accent-light);
    color:var(--text);
  }

  .small-btn{
    padding:8px 12px;
    border-radius:8px;
    border:1px solid var(--accent-light);
    background:#fff;
    cursor:pointer;
    font-size:13px;
    transition:all 0.2s ease;
  }

  .small-btn:hover{
    background:var(--accent-light);
  }

  /* Page reader - FULLSCREEN */
  .reader-fullscreen{
    display:none;
    position:fixed;
    inset:0;
    background:#f5f1ea;
    color:var(--text);
    z-index:9999;
    overflow:hidden;
    font-family:var(--book-font);
  }

  .reader-header{
    height:0;
    padding:0;
    overflow:hidden;
  }

  .reader-title{
    font-weight:700;
    font-family:var(--book-font);
    font-size:18px;
    max-width:50%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    color:var(--accent-dark);
  }

  .reader-body{
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#f5f1ea;
    position:relative;
  }

  .page-container{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
    padding:20px;
    max-width:1000px;
    margin:0 auto;
  }

  .page{
    width:100%;
    height:100%;
    background:#fff;
    border-radius:4px;
    box-shadow:0 10px 30px rgba(0,0,0,0.1);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    position:relative;
    border:1px solid #e6dfd5;
  }

  .page-content{
    flex:1;
    overflow:hidden;
    font-family:var(--book-font);
    font-size:var(--reader-font-size);
    line-height:1.6;
    text-align:justify;
    padding:40px;
    hyphens:auto;
    height:100%;
    box-sizing:border-box;
  }

  .page-content h1{
    font-size:20px;
    text-align:center;
    margin:10px 0;
    color:var(--accent-dark);
  }

  .page-content h2.chapter{
    font-size:16px;
    text-align:center;
    margin:20px 0;
    color:var(--accent);
  }

  .page-content p{
    margin:0 0 12px;
    text-indent:1.5em;
  }

  .page-content p:first-child{
    text-indent:0;
  }

  .reader-footer{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    justify-content:center;
    align-items:center;
    pointer-events:none;
    opacity:1;
    transition:opacity 0.5s ease;
  }

  .reader-footer.hidden{
    opacity:0;
  }

  .page-indicator{
    background:rgba(0,0,0,0.7);
    padding:8px 16px;
    border-radius:20px;
    font-size:14px;
    color:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,0.2);
  }

  .nav-hit-left,.nav-hit-right{
    position:absolute;
    top:0;
    bottom:0;
    width:40%;
    pointer-events:auto;
    z-index:10;
    cursor:pointer;
  }

  .nav-hit-left{
    left:0;
  }

  .nav-hit-right{
    right:0;
  }

  .nav-arrow{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    background:rgba(255,255,255,0.8);
    width:50px;
    height:50px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:20px;
    color:var(--accent);
    box-shadow:0 4px 12px rgba(0,0,0,0.1);
    opacity:0;
    transition:opacity 0.3s ease;
  }

  .nav-hit-left:hover .nav-arrow-left,
  .nav-hit-right:hover .nav-arrow-right{
    opacity:1;
  }

  .nav-arrow-left{
    left:20px;
  }

  .nav-arrow-right{
    right:20px;
  }

  /* Section-specific styling */
  #homeSection {
    background: linear-gradient(to bottom, #f9f5f1 0%, #f0e6d8 100%);
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }

  #homeSection .section-title {
    color: #8b6b4c;
    border-bottom: 2px solid #d4c4b5;
    padding-bottom: 10px;
  }

  #continueSection {
    background: linear-gradient(to bottom, #f1f9f1 0%, #e0f0e0 100%);
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }

  #continueSection .section-title {
    color: #5a7d5a;
    border-bottom: 2px solid #b8d4b8;
    padding-bottom: 10px;
  }

  #readLaterSection {
    background: linear-gradient(to bottom, #f9f1f1 0%, #f0e0e0 100%);
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }

  #readLaterSection .section-title {
    color: #7d5a5a;
    border-bottom: 2px solid #d4b8b8;
    padding-bottom: 10px;
  }

  /* small screens */
  @media (max-width:768px){
    .page-container{
      padding:10px;
    }
    
    .page-content{
      padding:30px;
    }
    
    .topbar{
      flex-direction:column;
      gap:15px;
      padding:15px;
    }
    
    .tabs{
      width:100%;
      justify-content:center;
    }
    
    .search-row{
      flex-direction:column;
      align-items:stretch;
    }
    
    #searchInput, #genreFilter{
      max-width:none;
    }
    
    .books-grid{
      grid-template-columns:repeat(auto-fill,minmax(200px,1fr));
    }
    
    .nav-hit-left, .nav-hit-right{
      width:30%;
    }
  }

  /* lists for Continue/Read Later */
  .list-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(260px,1fr));
    gap:20px;
  }

  .empty-note{
    color:var(--muted);
    padding:40px 20px;
    background:var(--card-bg);
    border-radius:12px;
    text-align:center;
    font-size:16px;
  }

  .section-title{
    font-size:24px;
    margin:0 0 20px;
  }

  /* Toast notification */
  .toast{
    position:fixed;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    background:var(--accent-dark);
    color:#fff;
    padding:12px 20px;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:10000;
    font-weight:500;
  }
</style>
</head>
<body>

<!-- Top -->
<div class="topbar">
  <div class="brand">
    <span class="brand-icon">ðŸ“š</span>
    <span>Gutenberg Library</span>
  </div>
  <div class="tabs" role="tablist" aria-label="Sections">
    <div class="tab active" id="tab-home">Home</div>
    <div class="tab" id="tab-continue">Continue</div>
    <div class="tab" id="tab-readlater">Read Later</div>
  </div>
</div>

<!-- search/filters -->
<div class="search-row">
  <input id="searchInput" placeholder="Search by title, author, or subject..." />
  <select id="genreFilter"><option value="">All Genres</option></select>
</div>

<!-- main content -->
<div class="layout" id="layout">
  <div id="homeSection">
    <h2 class="section-title">Browse Collection</h2>
    <div class="stats" id="stats">Loading books...</div>
    <div class="books-grid" id="booksGrid"><div class="loading">Loading data.txt...</div></div>
  </div>

  <div id="continueSection" style="display:none">
    <h2 class="section-title">Continue Reading</h2>
    <div id="continueList" class="list-grid"></div>
    <div id="continueEmpty" class="empty-note" style="display:none">Nothing to continue â€” open a book and it will appear here.</div>
  </div>

  <div id="readLaterSection" style="display:none">
    <h2 class="section-title">Read Later</h2>
    <div id="readLaterList" class="list-grid"></div>
    <div id="readLaterEmpty" class="empty-note" style="display:none">No saved books â€” add some using the "Read Later" button on a book card.</div>
  </div>
</div>

<!-- Reader fullscreen -->
<div class="reader-fullscreen" id="reader">
  <div class="reader-header">
    <div class="reader-title" id="readerTitle">Loading...</div>
  </div>

  <div class="reader-body">
    <div class="page-container" id="pageContainer">
      <div class="page">
        <div class="page-content" id="pageContent">Loading...</div>
      </div>
    </div>

    <div class="nav-hit-left" id="navLeft">
      <div class="nav-arrow nav-arrow-left">â—€</div>
    </div>
    <div class="nav-hit-right" id="navRight">
      <div class="nav-arrow nav-arrow-right">â–¶</div>
    </div>

    <div class="reader-footer" id="readerFooter">
      <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
    </div>
  </div>
</div>

<script>
/* CONFIG - EASILY EDITABLE VALUES */
const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your Worker
const PROXY_KEY = "dtech_secret";
const WORDS_PER_PAGE_DEFAULT = 500;         // Change this value to adjust words per page
const MIN_BALANCE_RATIO = 0.40;             // minimum fraction for last page before rebalancing
const FONT_SIZE_DEFAULT = 9;                // Change this value to adjust font size

/* STATE */
let books = [];
let pages = [];            // current pages (HTML strings)
let currentPage = 0;
let currentBook = null;    // {title, textUrl, cover, author}
let wordsPerPage = WORDS_PER_PAGE_DEFAULT;
let fontSize = FONT_SIZE_DEFAULT;
let pageIndicatorTimeout;

/* UI refs */
const booksGrid = document.getElementById('booksGrid');
const statsEl = document.getElementById('stats');
const pageContent = document.getElementById('pageContent');
const pageIndicator = document.getElementById('pageIndicator');
const readerEl = document.getElementById('reader');
const readerTitle = document.getElementById('readerTitle');
const readerFooter = document.getElementById('readerFooter');

/* Tabs */
const tabHome = document.getElementById('tab-home');
const tabContinue = document.getElementById('tab-continue');
const tabReadLater = document.getElementById('tab-readlater');
const homeSection = document.getElementById('homeSection');
const continueSection = document.getElementById('continueSection');
const readLaterSection = document.getElementById('readLaterSection');

tabHome.addEventListener('click', () => switchTab('home'));
tabContinue.addEventListener('click', () => switchTab('continue'));
tabReadLater.addEventListener('click', () => switchTab('readlater'));

function switchTab(id){
  tabHome.classList.remove('active'); tabContinue.classList.remove('active'); tabReadLater.classList.remove('active');
  homeSection.style.display = 'none'; continueSection.style.display = 'none'; readLaterSection.style.display = 'none';
  if (id==='home'){ tabHome.classList.add('active'); homeSection.style.display='block'; }
  if (id==='continue'){ tabContinue.classList.add('active'); continueSection.style.display='block'; renderContinueList(); }
  if (id==='readlater'){ tabReadLater.classList.add('active'); readLaterSection.style.display='block'; renderReadLaterList(); }
}

/* load data.txt and parse */
window.addEventListener('load', loadBooks);

async function loadBooks(){
  try {
    const r = await fetch('data.txt', {cache:'no-store'});
    if(!r.ok) throw new Error('Failed to fetch data.txt');
    const txt = await r.text();
    parseDataTxt(txt);
  } catch(err){
    console.error('loadBooks', err);
    booksGrid.innerHTML = '<div class="empty-note">Error loading data.txt â€” open console.</div>';
    statsEl.textContent = 'ðŸ“š 0 books loaded';
  }
}

function parseDataTxt(text){
  const lines = text.split(/\r?\n/);
  let currentGenre = '';
  let currentBook = null;
  const parsed = [];

  for (let raw of lines){
    const line = raw.trim();
    if (!line) continue;
    if (line.includes('ðŸŽ¯ GENRE:')) {
      const m = line.match(/ðŸŽ¯\s*GENRE:\s*([^\(]+)/i);
      currentGenre = m ? m[1].trim() : currentGenre;
      continue;
    }
    const bs = line.match(/^ðŸ“–\s*BOOK\s*\d+\s*:\s*(.+)$/i);
    if (bs){
      if (currentBook) parsed.push(currentBook);
      currentBook = { genre: currentGenre, title: bs[1].trim() };
      continue;
    }
    if (!currentBook) continue;
    if (line.includes('ðŸ‘¤ Author:')) currentBook.author = line.split('ðŸ‘¤ Author:')[1].trim();
    else if (line.includes('ðŸ“ Text URL:')) currentBook.textUrl = line.split('ðŸ“ Text URL:')[1].trim();
    else if (line.includes('ðŸ–¼ï¸  Cover:') || line.includes('ðŸ–¼ï¸ Cover:')) {
      // Extract cover URL correctly
      const coverMatch = line.match(/ðŸ–¼ï¸\s*Cover:\s*(.+)/i);
      if (coverMatch) currentBook.cover = coverMatch[1].trim();
    }
    else if (/^-{6,}/.test(line)){ parsed.push(currentBook); currentBook = null; }
  }
  if (currentBook) parsed.push(currentBook);

  books = parsed.map(b => ({
    title: b.title || 'Untitled',
    author: b.author || 'Unknown',
    genre: b.genre || 'Unknown',
    textUrl: b.textUrl || '',
    cover: b.cover || ''
  }));

  renderBookGrid();
  statsEl.textContent = `ðŸ“š ${books.length} books loaded â€¢ Use search/genre`;
  populateGenreFilter();
  renderContinueList();
}

/* render book grid */
function renderBookGrid(list=books){
  booksGrid.innerHTML = '';
  if (!list.length) { booksGrid.innerHTML = '<div class="empty-note">No books found.</div>'; return; }
  list.forEach(b=>{
    const card = document.createElement('div'); card.className='book-card';
    const coverWrap = document.createElement('div'); coverWrap.className='cover-wrap';
    if (b.cover){
      const img = document.createElement('img'); img.src = b.cover;
      img.alt = b.title;
      img.onload = ()=>{/* ok */};
      img.onerror = ()=>{ coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`; };
      coverWrap.appendChild(img);
    } else {
      coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    }

    const title = document.createElement('div'); title.className='book-title'; title.textContent = b.title;
    const author = document.createElement('div'); author.className='book-author'; author.textContent = b.author || '';
    const genre = document.createElement('div'); genre.className='book-genre'; genre.textContent = b.genre || '';
    const row = document.createElement('div'); row.className='card-row';

    const readBtn = document.createElement('button'); readBtn.className='btn'; readBtn.innerHTML = 'ðŸ“– Read';
    readBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openBook(b); });

    const rlBtn = document.createElement('button'); rlBtn.className='small-btn'; rlBtn.textContent = isInReadLater(b.textUrl) ? 'Remove' : 'Read Later';
    rlBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleReadLater(b); rlBtn.textContent = isInReadLater(b.textUrl) ? 'Remove' : 'Read Later'; });

    row.appendChild(readBtn); row.appendChild(rlBtn);
    card.appendChild(coverWrap); card.appendChild(title); card.appendChild(author); card.appendChild(genre); card.appendChild(row);
    // Clicking card reads
    card.addEventListener('click', ()=> openBook(b));
    booksGrid.appendChild(card);
  });
}

/* helper short title */
function shortTitle(t){
  if (!t) return 'No title';
  return t.split(' ').slice(0,3).join(' ');
}

/* Genre filter / search */
function populateGenreFilter(){
  const sel = document.getElementById('genreFilter'); sel.innerHTML = '<option value="">All Genres</option>';
  const uniq = [...new Set(books.map(b=>b.genre).filter(Boolean))].sort();
  uniq.forEach(g=>{ const o=document.createElement('option'); o.value=g; o.textContent=g; sel.appendChild(o); });
}
document.getElementById('searchInput').addEventListener('input', ()=>{
  const q = document.getElementById('searchInput').value.trim().toLowerCase();
  const genre = document.getElementById('genreFilter').value;
  const filtered = books.filter(b => ((b.title + ' ' + (b.author||'') + ' ' + (b.genre||'')).toLowerCase().includes(q) && (!genre || b.genre===genre)));
  renderBookGrid(filtered);
});
document.getElementById('genreFilter').addEventListener('change', ()=> document.getElementById('searchInput').dispatchEvent(new Event('input')));

/* READ LATER (localStorage) */
function getReadLater(){ try{ return JSON.parse(localStorage.getItem('gutenberg:readlater')||'[]') }catch(e){ return [] } }
function saveReadLater(list){ localStorage.setItem('gutenberg:readlater', JSON.stringify(list)); }
function isInReadLater(url){ if(!url) return false; return getReadLater().some(i=>i.textUrl===url); }
function toggleReadLater(book){
  const list = getReadLater();
  const idx = list.findIndex(b=>b.textUrl===book.textUrl);
  if (idx === -1) { list.unshift({title:book.title, author:book.author, textUrl:book.textUrl, cover:book.cover}); saveReadLater(list); showToast('Added to Read Later'); }
  else { list.splice(idx,1); saveReadLater(list); showToast('Removed from Read Later'); }
  renderReadLaterList();
}

/* render Read Later list */
function renderReadLaterList(){
  const wrap = document.getElementById('readLaterList');
  const empty = document.getElementById('readLaterEmpty');
  const list = getReadLater();
  wrap.innerHTML=''; empty.style.display='none';
  if (!list.length){ empty.style.display='block'; return; }
  list.forEach(b=>{
    const card=document.createElement('div'); card.className='book-card';
    const coverWrap = document.createElement('div'); coverWrap.className='cover-wrap';
    if (b.cover){ const img=document.createElement('img'); img.src=b.cover; img.onerror=()=>{coverWrap.innerHTML=`<div class="cover-placeholder">${shortTitle(b.title)}</div>`}; coverWrap.appendChild(img); } else coverWrap.innerHTML=`<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    const title=document.createElement('div'); title.className='book-title'; title.textContent=b.title;
    const author=document.createElement('div'); author.className='book-author'; author.textContent=b.author||'';
    const row=document.createElement('div'); row.className='card-row';
    const openBtn=document.createElement('button'); openBtn.className='btn'; openBtn.textContent='Open'; openBtn.addEventListener('click', ()=> openBook(b));
    const removeBtn=document.createElement('button'); removeBtn.className='small-btn'; removeBtn.textContent='Remove'; removeBtn.addEventListener('click', ()=>{ toggleReadLater(b); renderReadLaterList(); });
    row.appendChild(openBtn); row.appendChild(removeBtn);
    card.appendChild(coverWrap); card.appendChild(title); card.appendChild(author); card.appendChild(row);
    wrap.appendChild(card);
  });
}

/* CONTINUE READING: scan localStorage keys for last page markers */
function getContinueList(){
  const list=[];
  for (let i=0;i<localStorage.length;i++){
    const key = localStorage.key(i);
    if (!key) continue;
    if (key.startsWith('gutenberg:lastpage:')) {
      const url = key.replace('gutenberg:lastpage:','');
      const idx = parseInt(localStorage.getItem(key),10) || 0;
      // find book meta from books[] or readLater
      let meta = books.find(b=>b.textUrl===url) || getReadLater().find(b=>b.textUrl===url) || null;
      if (meta) list.push({title:meta.title, author:meta.author, textUrl:url, lastPage:idx});
      else list.push({title:url.split('/').slice(-1)[0], author:'', textUrl:url, lastPage:idx});
    }
  }
  // sort by most recently updated? can't easily get timestamp; keep insertion order
  return list;
}

function renderContinueList(){
  const wrap = document.getElementById('continueList');
  const empty = document.getElementById('continueEmpty');
  const list = getContinueList();
  wrap.innerHTML=''; empty.style.display='none';
  if (!list.length){ empty.style.display='block'; return; }
  list.forEach(item=>{
    const card=document.createElement('div'); card.className='book-card';
    const title=document.createElement('div'); title.className='book-title'; title.textContent=item.title;
    const author=document.createElement('div'); author.className='book-author'; author.textContent=item.author||'';
    const btnRow=document.createElement('div'); btnRow.className='card-row';
    const openBtn=document.createElement('button'); openBtn.className='btn'; openBtn.textContent='Continue'; openBtn.addEventListener('click', ()=> openBook({title:item.title,textUrl:item.textUrl}));
    const removeBtn=document.createElement('button'); removeBtn.className='small-btn'; removeBtn.textContent='Remove'; removeBtn.addEventListener('click', ()=> { localStorage.removeItem('gutenberg:lastpage:' + item.textUrl); renderContinueList(); });
    btnRow.appendChild(openBtn); btnRow.appendChild(removeBtn);
    card.appendChild(title); card.appendChild(author); card.appendChild(btnRow);
    wrap.appendChild(card);
  });
}

/* Open book: fetch via worker, clean, paginate and render at saved page (if any) */
async function openBook(book){
  // book may be object or textUrl string
  const b = (typeof book === 'string') ? books.find(x=>x.textUrl===book) : book;
  if (!b || !b.textUrl) { alert('No text URL'); return; }
  currentBook = { title: b.title, textUrl: b.textUrl, author: b.author, cover: b.cover };

  readerTitle.textContent = currentBook.title || 'Untitled';
  showReader();

  try {
    const resp = await fetch(`${PROXY_URL}?url=${encodeURIComponent(currentBook.textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`);
    if (!resp.ok) {
      const body = await resp.text().catch(()=>resp.statusText||'');
      throw new Error('Proxy fetch failed: ' + resp.status + ' ' + body);
    }
    const raw = await resp.text();
    const plain = extractPlainText(raw);
    paginateText(plain, wordsPerPage);
    // restore last page index
    const saved = parseInt(localStorage.getItem('gutenberg:lastpage:' + currentBook.textUrl) || '0', 10);
    currentPage = Math.max(0, Math.min(saved, pages.length - 1));
    renderPage(currentPage);
    // add to "continue" automatically (localStorage lastpage will be set by renderPage)
    renderContinueList();
  } catch (err) {
    console.error('openBook error', err);
    pageContent.innerHTML = `<div style="padding:18px;color:#c0392b">Failed to load book: ${escapeHtml(err.message || err)}</div>`;
  }
}

function showReader(){ 
  readerEl.style.display='block'; 
  document.body.style.overflow='hidden'; 
  // Reset page indicator visibility
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

function hideReader(){ 
  readerEl.style.display='none'; 
  document.body.style.overflow=''; 
  renderContinueList(); 
  renderReadLaterList(); 
}

/* clean Gutenberg headers/footers and return plain text (paragraphs separated by double newline) */
function extractPlainText(raw){
  let s = (raw || '').replace(/\r\n/g, '\n');
  const U = s.toUpperCase();
  const startMarkers = ['*** START OF THE PROJECT GUTENBERG EBOOK','*** START OF THIS PROJECT GUTENBERG EBOOK','***START OF THE PROJECT GUTENBERG EBOOK','*** START'];
  let startIdx = -1;
  for (const m of startMarkers){ const i = U.indexOf(m); if (i !== -1){ startIdx = i; break; } }
  if (startIdx !== -1){
    // find next double newline after marker
    const after = s.indexOf('\n\n', startIdx);
    if (after !== -1) s = s.substring(after + 2);
    else s = s.substring(startIdx);
  } else {
    // remove typical metadata top blocks heuristically
    s = s.replace(/Title:.*\nAuthor:.*\nRelease date:.*\n/gi,'');
    s = s.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
  }

  // Remove footer/common license
  const footerMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK','*** END OF THIS PROJECT GUTENBERG EBOOK','END OF PROJECT GUTENBERG','END OF THE PROJECT GUTENBERG'];
  let endIdx = -1;
  const SU = s.toUpperCase();
  for (const fm of footerMarkers){ const i = SU.indexOf(fm); if (i !== -1){ endIdx = i; break; } }
  if (endIdx !== -1) s = s.substring(0, endIdx);

  // strip extra license paragraph remnants
  s = s.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
  // normalize repeated blank lines
  s = s.replace(/\n{3,}/g, '\n\n').trim();

  return s;
}

/* PAGINATION: Improved algorithm to prevent cutting content */
function paginateText(plain, wordsPerPageLocal){
  const paragraphs = plain.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);

  // Build pages by preserving paragraph boundaries
  const pagesArr = [];
  let currentPageText = '';
  let currentWordCount = 0;

  for (let para of paragraphs){
    const words = para.split(/\s+/).filter(Boolean);
    const paraWordCount = words.length;
    
    // If adding this paragraph would exceed the limit
    if (currentWordCount + paraWordCount > wordsPerPageLocal) {
      // If current page has content, push it
      if (currentPageText) {
        pagesArr.push(currentPageText);
        currentPageText = '';
        currentWordCount = 0;
      }
      
      // If paragraph is too long for a single page, split it
      if (paraWordCount > wordsPerPageLocal) {
        let remainingWords = paraWordCount;
        let startIdx = 0;
        
        while (remainingWords > 0) {
          const take = Math.min(remainingWords, wordsPerPageLocal);
          const chunk = words.slice(startIdx, startIdx + take).join(' ');
          pagesArr.push(chunk);
          startIdx += take;
          remainingWords -= take;
        }
      } else {
        // Paragraph fits in a new page
        currentPageText = para;
        currentWordCount = paraWordCount;
      }
    } else {
      // Add paragraph to current page
      if (currentPageText) {
        currentPageText += '\n\n' + para;
      } else {
        currentPageText = para;
      }
      currentWordCount += paraWordCount;
    }
  }
  
  // Don't forget the last page
  if (currentPageText) {
    pagesArr.push(currentPageText);
  }

  // Convert pages to HTML
  pages = pagesArr.map(pageText => {
    // Split by paragraphs and wrap each in <p> tags
    const pageParagraphs = pageText.split(/\n\s*\n/).filter(Boolean);
    return pageParagraphs.map(p => `<p>${escapeHtml(p)}</p>`).join('');
  });
  
  // Ensure non-empty
  if (!pages.length) pages = ['<p>No content extracted.</p>'];
}

/* render a page (no horizontal scroll) */
function renderPage(idx){
  if (!pages || !pages.length) { pageContent.innerHTML = '<div class="empty-note">No pages</div>'; pageIndicator.textContent = 'Page 0 / 0'; return; }
  currentPage = Math.max(0, Math.min(idx, pages.length - 1));
  // set font size
  pageContent.style.fontSize = fontSize + 'px';
  pageContent.innerHTML = pages[currentPage];
  pageIndicator.textContent = `Page ${currentPage + 1} / ${pages.length}`;
  // save last page
  try { localStorage.setItem('gutenberg:lastpage:' + currentBook.textUrl, String(currentPage)); } catch(e){}
  // ensure continue list refresh
  renderContinueList();
  
  // Show page indicator and set timeout to fade it
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

/* navigation handlers */
function navigatePage(direction) {
  if (direction === 'next') {
    renderPage(currentPage + 1);
  } else if (direction === 'prev') {
    renderPage(currentPage - 1);
  }
}

/* keyboard navigation */
window.addEventListener('keydown', (e)=>{
  if (readerEl.style.display === 'block'){
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { 
      navigatePage('next'); 
      e.preventDefault(); 
    }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { 
      navigatePage('prev'); 
      e.preventDefault(); 
    }
    if (e.key === 'Escape') hideReader();
  }
});

/* swipe/tap navigation areas */
let tx=0, ty=0;
function touchStart(e){ 
  const t = e.touches ? e.touches[0] : e; 
  tx = t.clientX; 
  ty = t.clientY; 
  
  // Show page indicator on touch
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
}
function touchEnd(e){ 
  const t = e.changedTouches ? e.changedTouches[0] : e; 
  const dx = t.clientX - tx; 
  const dy = t.clientY - ty; 
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30){ 
    if (dx < 0) navigatePage('next'); 
    else navigatePage('prev'); 
  }
  
  // Set timeout to hide page indicator after touch
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

document.getElementById('navLeft').addEventListener('touchstart', touchStart); 
document.getElementById('navRight').addEventListener('touchstart', touchStart);
document.getElementById('navLeft').addEventListener('touchend', touchEnd); 
document.getElementById('navRight').addEventListener('touchend', touchEnd);
document.getElementById('navLeft').addEventListener('click', ()=> navigatePage('prev')); 
document.getElementById('navRight').addEventListener('click', ()=> navigatePage('next'));

// Click anywhere on reader to show page indicator temporarily
readerEl.addEventListener('click', (e) => {
  // Don't trigger if clicking on navigation areas
  if (e.target.id !== 'navLeft' && e.target.id !== 'navRight' && 
      !e.target.closest('#navLeft') && !e.target.closest('#navRight')) {
    clearTimeout(pageIndicatorTimeout);
    readerFooter.classList.remove('hidden');
    pageIndicatorTimeout = setTimeout(() => {
      readerFooter.classList.add('hidden');
    }, 3000);
  }
});

/* CONTINUE & READ LATER helpers - after page change, these lists update */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* small toast */
function showToast(text){
  const t = document.createElement('div'); t.textContent = text; t.className = 'toast';
  document.body.appendChild(t); setTimeout(()=>t.remove(), 2000);
}

/* render both lists initially */
renderContinueList();
renderReadLaterList();

</script>
</body>
</html>
