<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Gutenberg Library Reader</title>
    <style>
        /* ... keep your existing CSS or add styles below ... */
        .container { max-width: 1000px; margin: 20px auto; padding: 10px; }
        .books-grid { display: grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap: 14px; }
        .book-card { background:#fff; border-radius:8px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); cursor:pointer; display:flex; flex-direction:column; gap:8px; }
        .book-cover { height:160px; border-radius:6px; background-size:cover; background-position:center; display:flex; align-items:center; justify-content:center; font-weight:600; color:#333; background:#eee; padding:10px; text-align:center; }
        .reader-overlay { display:none; position:fixed; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); z-index:9999; }
        .reader-container { width:90%; max-width:920px; height:85%; background:#fff; border-radius:10px; overflow:auto; display:flex; flex-direction:column; }
        .reader-header { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid #eee; }
        .reader-content { padding:16px; overflow:auto; flex:1; }
        .loading { padding:20px; color:#666; }
        .error { color: #c0392b; padding:12px; }
        .read-btn { margin-top:auto; padding:8px 10px; border:none; border-radius:6px; background:#3498db; color:#fff; cursor:pointer; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>📚 Gutenberg Library</h1>
            <div class="subtitle">Explore thousands of free classic books</div>
        </header>

        <div class="controls">
            <div class="search-filter">
                <input type="text" id="searchInput" placeholder="Search books by title or author...">
                <select id="genreFilter">
                    <option value="">All Genres</option>
                </select>
            </div>
        </div>

        <div class="stats" id="stats">Loading books...</div>

        <div class="books-grid" id="booksGrid">
            <div class="loading">Loading books from data.txt...</div>
        </div>
    </div>

    <!-- Book Reader -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <div class="reader-header">
                <div class="reader-title" id="readerBookTitle">Loading...</div>
                <div class="reader-controls">
                    <button id="decreaseFS">A-</button>
                    <button id="increaseFS">A+</button>
                    <button id="closeReaderBtn">✕ Close</button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                <div class="loading">Loading book content...</div>
            </div>
        </div>
    </div>

    <script>
        // === CONFIG - replace these with your worker URL and key ===
        const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // <-- set this to your worker URL
        const PROXY_KEY = "dtech_secret"; // <-- set this to the same secret on the worker
        const MAX_DISPLAY_CHARS = 5000000; // safety on client (not strict), optional

        let books = [];
        let currentFontSize = 18;
        window.currentBookUrl = '';

        // Load books from data.txt
        async function loadBooks() {
            try {
                const response = await fetch('data.txt');
                const text = await response.text();
                parseBooks(text);
            } catch (error) {
                console.error('Error loading data.txt:', error);
                document.getElementById('booksGrid').innerHTML =
                    '<div class="error">Error loading books data. Make sure data.txt is in the same folder.</div>';
            }
        }

        function parseBooks(text) {
            const lines = text.split('\\n');
            let currentBook = null;
            let inBookSection = false;
            let currentGenre = '';

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) continue;

                if (line.includes('🎯 GENRE:')) {
                    currentGenre = line.split('🎯 GENRE:')[1].split('(')[0].trim();
                    continue;
                }

                if (line.includes('📖 BOOK')) {
                    if (currentBook) books.push(currentBook);
                    currentBook = { genre: currentGenre, title: line.split('📖 BOOK')[1].split(':')[1].trim() };
                    inBookSection = true;
                    continue;
                }

                if (!inBookSection || !currentBook) continue;

                if (line.includes('👤 Author:')) {
                    currentBook.author = line.split('👤 Author:')[1].trim();
                } else if (line.includes('🆔 ID:')) {
                    currentBook.id = line.split('🆔 ID:')[1].trim();
                } else if (line.includes('📊 Downloads:')) {
                    currentBook.downloads = line.split('📊 Downloads:')[1].trim();
                } else if (line.includes('🖼️  Cover:')) {
                    currentBook.cover = line.split('🖼️  Cover:')[1].trim();
                } else if (line.includes('📝 Text URL:')) {
                    currentBook.textUrl = line.split('📝 Text URL:')[1].trim();
                } else if (line.includes('📄 Format:')) {
                    currentBook.format = line.split('📄 Format:')[1].trim();
                } else if (line.includes('🏷️  Subjects:')) {
                    currentBook.subjects = line.split('🏷️  Subjects:')[1].trim();
                } else if (line.includes('📚 Bookshelves:')) {
                    currentBook.bookshelves = line.split('📚 Bookshelves:')[1].trim();
                }

                if (line.includes('--------------------------------------------------')) {
                    inBookSection = false;
                }
            }

            if (currentBook) books.push(currentBook);

            // fill defaults
            books = books.map(b => ({
                title: b.title || 'Untitled',
                author: b.author || 'Unknown',
                genre: b.genre || 'Unknown',
                textUrl: b.textUrl || '',
                cover: b.cover || '',
                downloads: b.downloads || '0',
                subjects: b.subjects || '',
                id: b.id || ''
            }));

            displayBooks(books);
            updateStats();
            populateGenres();
        }

        function displayBooks(booksToShow) {
            const grid = document.getElementById('booksGrid');
            grid.innerHTML = '';

            if (!booksToShow || booksToShow.length === 0) {
                grid.innerHTML = '<div class="no-books">No books found matching your search.</div>';
                return;
            }

            booksToShow.forEach(book => {
                const card = document.createElement('div');
                card.className = 'book-card';

                // click opens book
                card.addEventListener('click', () => openBook(book.textUrl, book.title));

                const cover = document.createElement('div');
                cover.className = 'book-cover';
                if (book.cover) {
                    cover.style.backgroundImage = `url('${book.cover}')`;
                } else {
                    cover.textContent = book.title.length > 30 ? book.title.substring(0, 30) + '...' : book.title;
                }

                const titleDiv = document.createElement('div');
                titleDiv.className = 'book-title';
                titleDiv.textContent = book.title;

                const authorDiv = document.createElement('div');
                authorDiv.className = 'book-author';
                authorDiv.textContent = book.author;

                const metaDiv = document.createElement('div');
                metaDiv.className = 'book-meta';
                metaDiv.innerHTML = `📊 ${book.downloads} downloads<br>🏷️ ${book.genre}`;

                const readBtn = document.createElement('button');
                readBtn.className = 'read-btn';
                readBtn.textContent = '📖 Read Book';
                readBtn.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    openBook(book.textUrl, book.title);
                });

                card.appendChild(cover);
                card.appendChild(titleDiv);
                card.appendChild(authorDiv);
                card.appendChild(metaDiv);
                card.appendChild(readBtn);

                grid.appendChild(card);
            });
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            stats.textContent = `📚 ${books.length} books loaded • Use search and filters to find books`;
        }

        function populateGenres() {
            const genreFilter = document.getElementById('genreFilter');
            const genres = [...new Set(books.map(book => book.genre).filter(Boolean))].sort();
            genres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                genreFilter.appendChild(option);
            });
        }

        // Search and filter
        document.getElementById('searchInput').addEventListener('input', filterBooks);
        document.getElementById('genreFilter').addEventListener('change', filterBooks);

        function filterBooks() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const genreValue = document.getElementById('genreFilter').value;
            const filtered = books.filter(book => {
                const matchesSearch = (book.title || '').toLowerCase().includes(searchTerm) ||
                                      (book.author || '').toLowerCase().includes(searchTerm);
                const matchesGenre = !genreValue || book.genre === genreValue;
                return matchesSearch && matchesGenre;
            });
            displayBooks(filtered);
        }

        // Reader functions
        document.getElementById('decreaseFS').addEventListener('click', () => changeFontSize(-1));
        document.getElementById('increaseFS').addEventListener('click', () => changeFontSize(1));
        document.getElementById('closeReaderBtn').addEventListener('click', closeReader);

        document.getElementById('readerOverlay').addEventListener('click', function(e) {
            if (e.target === this) closeReader();
        });

        async function openBook(textUrl, title) {
            const overlay = document.getElementById('readerOverlay');
            const contentDiv = document.getElementById('readerContent');
            const titleDiv = document.getElementById('readerBookTitle');

            titleDiv.textContent = title;
            overlay.style.display = 'flex';
            contentDiv.innerHTML = '<div class="loading">Loading book content...</div>';
            window.currentBookUrl = textUrl;

            try {
                // Build proxy fetch URL
                if (!textUrl) throw new Error('No text URL provided for this book.');

                const encoded = encodeURIComponent(textUrl);
                const proxyFetchUrl = `${PROXY_URL}?url=${encoded}&key=${encodeURIComponent(PROXY_KEY)}`;

                const resp = await fetch(proxyFetchUrl, { method: 'GET' });
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status} - ${await resp.text()}`);
                }

                const text = await resp.text();

                if (!text || text.length < 20) {
                    throw new Error('Received empty or too-short content.');
                }

                if (text.length > MAX_DISPLAY_CHARS) {
                    // safety: do not crash the browser if file is too big
                    contentDiv.innerHTML = `
                        <div class="error">
                            Book too large to render in browser (${(text.length/1024/1024).toFixed(2)}MB).<br>
                            <button onclick="window.open('${textUrl}', '_blank')"
                                style="padding:10px 16px; background:#3498db; color:#fff; border:none; border-radius:6px;">
                                Open original file in new tab
                            </button>
                        </div>`;
                    return;
                }

                const cleanedContent = cleanBookContent(text, title);
                contentDiv.innerHTML = `<div class="book-content" style="font-size:${currentFontSize}px;">${cleanedContent}</div>`;
            } catch (error) {
                console.error('Error loading book:', error);
                contentDiv.innerHTML = `
                    <div class="error">
                        Failed to load book content: ${error.message}<br><br>
                        <button onclick="window.open('${textUrl}', '_blank')" style="
                            padding: 10px 20px;
                            background: #3498db;
                            color: white;
                            border: none;
                            border-radius: 5px;
                            cursor: pointer;
                        ">
                            Open in New Tab Instead
                        </button>
                    </div>
                `;
            }
        }

        function cleanBookContent(text, title) {
            // (same cleaning logic you already had — kept mostly intact)
            let content = text;

            const startMarkers = [
                '*** START OF THE PROJECT GUTENBERG EBOOK',
                '***START OF THE PROJECT GUTENBERG EBOOK',
                '*** START OF THIS PROJECT GUTENBERG EBOOK',
                'Produced by',
                'Transcriber'
            ];

            let startIndex = -1;
            for (const marker of startMarkers) {
                startIndex = content.indexOf(marker);
                if (startIndex !== -1) break;
            }

            if (startIndex !== -1) {
                const afterStart = content.substring(startIndex);
                const firstLineBreak = afterStart.indexOf('\\n');
                content = firstLineBreak !== -1 ? afterStart.substring(firstLineBreak + 1) : afterStart;
            }

            const headerPatterns = [
                /The Project Gutenberg eBook of .+?\\n\\n/gs,
                /This ebook is for the use of anyone anywhere.+?www\\.gutenberg\\.org\\./gs,
                /Title: .+?\\nAuthor: .+?\\nRelease date: .+?\\n/gs,
                /Language: .+?\\nCredits: .+?\\n/gs
            ];
            headerPatterns.forEach(p => content = content.replace(p, ''));

            const storyStartMarkers = ['CHAPTER', 'Chapter', 'I\\n', 'THE\\n', 'It was', 'In the', 'Once upon'];
            for (const marker of storyStartMarkers) {
                const idx = content.indexOf(marker);
                if (idx !== -1 && idx < 1000) { content = content.substring(idx); break; }
            }

            const endMarkers = [
                '*** END OF THE PROJECT GUTENBERG EBOOK',
                '*** END OF THIS PROJECT GUTENBERG EBOOK',
                'End of the Project Gutenberg',
                'End of Project Gutenberg'
            ];
            for (const m of endMarkers) {
                const idx = content.indexOf(m);
                if (idx !== -1) { content = content.substring(0, idx); break; }
            }

            // Convert lines to paragraphs and headings
            const lines = content.split('\\n');
            let html = [];
            let para = [];

            html.push(`<h1>${escapeHtml(title)}</h1>`);
            html.push('<div style="text-align:center;margin:30px 0;padding:20px;background:#f8f9fa;border-radius:10px;"><em>From Project Gutenberg • Free eBook</em></div>');

            for (let i=0;i<lines.length;i++){
                const line = lines[i].trim();
                if (!line) {
                    if (para.length) { html.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
                    continue;
                }

                if ((line === line.toUpperCase() && line.length < 100 && !line.includes('.') && !line.includes(',')) ||
                    line.startsWith('CHAPTER') || line.startsWith('Chapter')) {
                    if (para.length) { html.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
                    html.push(`<h2 class="chapter">${escapeHtml(line)}</h2>`);
                } else {
                    para.push(line);
                }
            }

            if (para.length) html.push(`<p>${escapeHtml(para.join(' '))}</p>`);

            if (html.length <= 3) {
                return `<div class="error"><p>Could not extract readable content from this book.</p>
                    <p>The book file might be in a different format.</p>
                    <button onclick="window.open('${window.currentBookUrl}','_blank')" style="padding:10px 16px;background:#3498db;color:#fff;border:none;border-radius:6px;">View Original File</button>
                </div>`;
            }

            return html.join('\\n');
        }

        function escapeHtml(s) {
            return (s+'').replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
        }

        function closeReader() {
            document.getElementById('readerOverlay').style.display = 'none';
            document.getElementById('readerContent').innerHTML = '';
        }

        function changeFontSize(delta) {
            currentFontSize = Math.max(14, Math.min(28, currentFontSize + delta));
            const bookContent = document.querySelector('.book-content');
            if (bookContent) bookContent.style.fontSize = currentFontSize + 'px';
        }

        // Start
        window.addEventListener('load', loadBooks);
    </script>
</body>
</html>