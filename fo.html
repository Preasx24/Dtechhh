<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gutenberg Library Reader</title>
  <style>
    /* ---- page layout ---- */
    :root{
      --reader-bg: #fff;
      --reader-pad: 40px;
      --reader-gap: 48px;
      --accent: #2d9cdb;
      --max-reader-width: 1200px;
      --book-font: "Georgia", "Times New Roman", serif;
    }

    body { font-family: system-ui, Arial, sans-serif; background:#f5f7fa; color:#222; margin:0; padding:20px; }
    .container { max-width:1100px; margin:0 auto; }
    header h1 { margin:0 0 6px 0; }
    .controls { display:flex; gap:12px; margin:10px 0 18px; align-items:center; }
    #searchInput { padding:8px 10px; width:320px; border-radius:6px; border:1px solid #ddd; }
    #genreFilter { padding:8px; border-radius:6px; border:1px solid #ddd; }
    .stats { margin-bottom:12px; color:#555; }

    .books-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:14px; }
    .book-card { background:#fff; border-radius:8px; padding:12px; box-shadow:0 2px 8px rgba(0,0,0,.06); display:flex; flex-direction:column; gap:8px; min-height:220px; cursor:pointer; }
    .book-cover { height:140px; border-radius:6px; background:#eee; display:flex; align-items:center; justify-content:center; font-weight:600; text-align:center; padding:10px; background-size:cover; background-position:center; color:#222; }
    .book-title { font-weight:700; font-size:15px; }
    .book-author { color:#666; font-size:13px; }
    .book-meta { color:#666; font-size:12px; margin-top:6px; }
    .read-btn { margin-top:auto; border:none; background:var(--accent); color:#fff; padding:8px 10px; border-radius:6px; cursor:pointer; }

    /* ---- reader overlay (full-page book viewer) ---- */
    .reader-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); align-items:center; justify-content:center; z-index:999; padding:20px; }
    .reader-container { width:98%; max-width:var(--max-reader-width); height:90%; background:var(--reader-bg); border-radius:10px; overflow:hidden; display:flex; flex-direction:column; box-shadow:0 8px 30px rgba(0,0,0,0.3); }

    .reader-header { display:flex; justify-content:space-between; align-items:center; padding:14px 18px; border-bottom:1px solid #eee; gap:12px; }
    .reader-title { font-weight:700; font-family:var(--book-font); font-size:18px; max-width:60%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .reader-controls { display:flex; gap:8px; align-items:center; }

    .reader-controls button { padding:8px 10px; border-radius:6px; border:none; background:#eee; cursor:pointer; }
    .reader-controls button.primary { background:var(--accent); color:#fff; }
    .page-indicator { font-size:14px; color:#444; min-width:120px; text-align:center; }

    /* ---- book area: columns create pages horizontally ---- */
    .reader-content {
      flex:1;
      overflow-x:auto;
      overflow-y:hidden;
      /* column properties turned on dynamically in JS, but defaults below */
      column-gap: var(--reader-gap);
      padding: var(--reader-pad);
      background: linear-gradient(180deg, #fff, #fff);
      -webkit-font-smoothing:antialiased;
      scroll-behavior: smooth;
      white-space: normal;
    }

    /* book style */
    .book-content {
      font-family: var(--book-font);
      line-height:1.8;
      font-size:18px;
      hyphens: auto;
      text-align: justify;
      color:#111;
      column-fill: auto; /* fill pages left->right */
    }

    .book-content h1 { text-align:center; font-size:28px; margin:10px 0 24px; }
    .book-content h2.chapter { text-align:center; margin:26px 0 12px; font-size:20px; font-weight:700; }
    .book-content p { margin:0 0 14px; }

    /* small screens: single column by default */
    @media (max-width:700px) {
      :root { --reader-pad: 18px; --reader-gap: 28px; }
      .reader-container { height:95%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üìö Gutenberg Library</h1>
      <div class="subtitle">Explore thousands of free classic books</div>
    </header>

    <div class="controls">
      <input type="text" id="searchInput" placeholder="Search books by title or author...">
      <select id="genreFilter">
        <option value="">All Genres</option>
      </select>
    </div>

    <div class="stats" id="stats">Loading books...</div>
    <div class="books-grid" id="booksGrid"><div class="loading">Loading books from data.txt...</div></div>
  </div>

  <!-- Reader -->
  <div class="reader-overlay" id="readerOverlay" aria-hidden="true">
    <div class="reader-container" role="dialog" aria-modal="true" aria-labelledby="readerBookTitle">
      <div class="reader-header">
        <div class="reader-title" id="readerBookTitle">Loading...</div>
        <div class="reader-controls">
          <button id="prevPage" title="Previous page">‚óÄ Prev</button>
          <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
          <button id="nextPage" title="Next page">Next ‚ñ∂</button>
          <button id="decreaseFS" title="Smaller text">A-</button>
          <button id="increaseFS" title="Larger text">A+</button>
          <button id="closeReaderBtn" class="primary" title="Close reader">Close ‚úï</button>
        </div>
      </div>
      <div class="reader-content" id="readerContent" tabindex="0" role="document">
        <div class="loading">Loading book content...</div>
      </div>
    </div>
  </div>

  <script>
  // === CONFIG - set your worker URL and key ===
  const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your worker
  const PROXY_KEY = "dtech_secret"; // secret (must match worker)

  // basic state
  let books = [];
  let currentFontSize = 18;
  let currentPageIndex = 0;
  let totalPages = 1;

  // --------------- load & parse data.txt (unchanged flow) ---------------
  async function loadBooks() {
    try {
      const response = await fetch('data.txt', { cache: 'no-store' });
      if (!response.ok) throw new Error('Failed to fetch data.txt: ' + response.status);
      const text = await response.text();
      parseBooks(text);
    } catch (err) {
      console.error('loadBooks error:', err);
      document.getElementById('booksGrid').innerHTML = '<div class="error">Error loading data.txt ‚Äî check console</div>';
      document.getElementById('stats').textContent = 'üìö 0 books loaded ‚Ä¢ Use search and filters to find books';
    }
  }

  function parseBooks(text) {
    const lines = text.split(/\r?\n/);
    let currentGenre = '';
    let currentBook = null;
    books = [];

    for (let rawLine of lines) {
      const line = rawLine.trim();
      if (!line) continue;

      if (line.includes('üéØ GENRE:')) {
        const m = line.match(/üéØ\s*GENRE:\s*([^\(]+)/i);
        currentGenre = m ? m[1].trim() : currentGenre;
        continue;
      }

      let bookStart = line.match(/^üìñ\s*BOOK\s*\d+\s*:\s*(.+)$/i);
      if (bookStart) {
        if (currentBook) books.push(currentBook);
        currentBook = { genre: currentGenre, title: bookStart[1].trim() };
        continue;
      }

      if (!currentBook) continue;

      if (line.includes('üë§ Author:')) currentBook.author = line.split('üë§ Author:')[1].trim();
      else if (line.includes('üÜî ID:')) currentBook.id = line.split('üÜî ID:')[1].trim();
      else if (line.includes('üìä Downloads:')) currentBook.downloads = line.split('üìä Downloads:')[1].trim();
      else if (line.includes('üåê Language:')) currentBook.language = line.split('üåê Language:')[1].trim();
      else if (line.includes('üñºÔ∏è  Cover:') || line.includes('üñºÔ∏è Cover:')) currentBook.cover = (line.split('üñºÔ∏è')[1] || '').replace(/^Cover:\s*/i, '').trim();
      else if (line.includes('üìù Text URL:')) currentBook.textUrl = line.split('üìù Text URL:')[1].trim();
      else if (line.includes('üìÑ Format:')) currentBook.format = line.split('üìÑ Format:')[1].trim();
      else if (line.includes('üè∑Ô∏è  Subjects:') || line.includes('üè∑Ô∏è Subjects:')) currentBook.subjects = (line.split('üè∑Ô∏è')[1] || '').replace(/^Subjects?:\s*/i, '').trim();
      else if (line.includes('üìö Bookshelves:')) currentBook.bookshelves = line.split('üìö Bookshelves:')[1].trim();
      else if (/^-{6,}/.test(line)) { if (currentBook) { books.push(currentBook); currentBook = null; } }
    }
    if (currentBook) books.push(currentBook);

    books = books.map(b => ({
      title: b.title || 'Untitled',
      author: b.author || 'Unknown',
      genre: b.genre || 'Unknown',
      textUrl: b.textUrl || '',
      cover: b.cover || '',
      downloads: b.downloads || '0',
      subjects: b.subjects || '',
      id: b.id || ''
    }));

    displayBooks(books);
    updateStats();
    populateGenres();
  }

  function displayBooks(list) {
    const grid = document.getElementById('booksGrid');
    grid.innerHTML = '';
    if (!list || list.length === 0) {
      grid.innerHTML = '<div class="no-books">No books found matching your search.</div>';
      return;
    }

    list.forEach(book => {
      const card = document.createElement('div');
      card.className = 'book-card';
      card.addEventListener('click', () => openBook(book.textUrl, book.title));

      const cover = document.createElement('div');
      cover.className = 'book-cover';
      if (book.cover) { cover.style.backgroundImage = `url("${book.cover}")`; }
      else { cover.textContent = book.title.length > 30 ? book.title.slice(0,30) + '...' : book.title; }

      const t = document.createElement('div'); t.className = 'book-title'; t.textContent = book.title;
      const a = document.createElement('div'); a.className = 'book-author'; a.textContent = book.author;
      const meta = document.createElement('div'); meta.className = 'book-meta'; meta.innerHTML = `üìä ${book.downloads} downloads<br>üè∑Ô∏è ${book.genre}`;
      const btn = document.createElement('button'); btn.className = 'read-btn'; btn.textContent = 'üìñ Read Book';
      btn.addEventListener('click', (ev) => { ev.stopPropagation(); openBook(book.textUrl, book.title); });

      card.appendChild(cover); card.appendChild(t); card.appendChild(a); card.appendChild(meta); card.appendChild(btn);
      grid.appendChild(card);
    });
  }

  function updateStats() {
    document.getElementById('stats').textContent = `üìö ${books.length} books loaded ‚Ä¢ Use search and filters to find books`;
  }

  function populateGenres(){
    const select = document.getElementById('genreFilter'); select.innerHTML = '<option value="">All Genres</option>';
    const unique = [...new Set(books.map(b => b.genre).filter(Boolean))].sort();
    unique.forEach(g => { const o = document.createElement('option'); o.value = g; o.textContent = g; select.appendChild(o); });
  }

  document.getElementById('searchInput').addEventListener('input', applyFilters);
  document.getElementById('genreFilter').addEventListener('change', applyFilters);

  function applyFilters(){
    const q = document.getElementById('searchInput').value.trim().toLowerCase();
    const genre = document.getElementById('genreFilter').value;
    const filtered = books.filter(b => {
      const matchesQ = !q || (b.title + ' ' + b.author + ' ' + (b.subjects||'')).toLowerCase().includes(q);
      const matchesGenre = !genre || b.genre === genre;
      return matchesQ && matchesGenre;
    });
    displayBooks(filtered);
  }

  // --------------- READER: fetch text from Worker and show paginated book ---------------
  document.getElementById('prevPage').addEventListener('click', () => changePage(-1));
  document.getElementById('nextPage').addEventListener('click', () => changePage(1));
  document.getElementById('decreaseFS').addEventListener('click', () => adjustFont(-1));
  document.getElementById('increaseFS').addEventListener('click', () => adjustFont(1));
  document.getElementById('closeReaderBtn').addEventListener('click', closeReader);
  document.getElementById('readerContent').addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') changePage(1);
    if (e.key === 'ArrowLeft') changePage(-1);
  });

  async function openBook(textUrl, title) {
    const overlay = document.getElementById('readerOverlay');
    const contentDiv = document.getElementById('readerContent');
    const titleDiv = document.getElementById('readerBookTitle');

    titleDiv.textContent = title || 'Loading...';
    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden','false');
    contentDiv.innerHTML = '<div class="loading">Loading book content...</div>';
    window.currentBookUrl = textUrl || '';

    if (!textUrl) {
      contentDiv.innerHTML = '<div class="error">No text URL available for this book.</div>';
      return;
    }

    try {
      const proxyFetchUrl = `${PROXY_URL}?url=${encodeURIComponent(textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`;
      const resp = await fetch(proxyFetchUrl);
      if (!resp.ok) {
        const body = await resp.text().catch(()=>resp.statusText||'');
        throw new Error(`Proxy fetch failed: ${resp.status} ${body}`);
      }

      const rawText = await resp.text();
      // CLEAN the content: remove Gutenberg header/footer and return HTML
      const html = cleanAndExtractContent(rawText, title);
      contentDiv.innerHTML = `<div class="book-content" id="bookContent">${html}</div>`;

      // Init pagination after content is inserted
      currentPageIndex = 0;
      setTimeout(() => initPagination(), 80); // slight delay to allow layout
    } catch (err) {
      console.error('openBook error:', err);
      contentDiv.innerHTML = `<div class="error">Failed to load book: ${escapeHtml(err.message || err)}<br><br>
        <button onclick="window.open('${escapeForJsWindow(textUrl)}','_blank')">Open original file</button>
      </div>`;
    }
  }

  // Remove Gutenberg header/footer and return HTML starting from first real content after START marker.
  function cleanAndExtractContent(text, title){
    let content = text || '';
    // Normalize line endings
    content = content.replace(/\r\n/g, '\n');

    // 1) Try to locate robust start marker (several variants)
    const upper = content.toUpperCase();
    const startPatterns = [
      '*** START OF THE PROJECT GUTENBERG EBOOK',
      '*** START OF THIS PROJECT GUTENBERG EBOOK',
      '***START OF THE PROJECT GUTENBERG EBOOK',
      '*** START',
      '***START'
    ];

    let startIndex = -1;
    let matchedPattern = '';
    for (const p of startPatterns){
      const idx = upper.indexOf(p);
      if (idx !== -1) { startIndex = idx; matchedPattern = p; break; }
    }

    if (startIndex !== -1) {
      // find the first blank line (double newline) after the marker to start content after the header block
      const afterMarkerPos = startIndex + matchedPattern.length;
      let doubleNL = content.indexOf('\n\n', afterMarkerPos);
      if (doubleNL === -1) {
        // try single newline then skip next line (some files have marker on own line)
        doubleNL = content.indexOf('\n', afterMarkerPos);
      }
      if (doubleNL !== -1) {
        // advance to after the double newline (skip header)
        content = content.substring(doubleNL + 2);
      } else {
        // fallback: cut right after marker
        content = content.substring(afterMarkerPos);
      }
    } else {
      // If no marker found, try to strip known Gutenberg top blocks like "Title: ...\nAuthor: ...\n"
      content = content.replace(/^([\s\S]{0,1200}?)(Title:.*\nAuthor:.*\nRelease date:.*\n)/i, '');
    }

    // 2) Remove trailing Project Gutenberg footer if present
    const footerMarkers = [
      '*** END OF THE PROJECT GUTENBERG EBOOK',
      '*** END OF THIS PROJECT GUTENBERG EBOOK',
      'END OF THE PROJECT GUTENBERG',
      'END OF PROJECT GUTENBERG'
    ];
    for (const fm of footerMarkers){
      const fidx = content.toUpperCase().indexOf(fm);
      if (fidx !== -1) { content = content.substring(0, fidx); break; }
    }

    // 3) Remove common licensing paragraphs that may remain
    content = content.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
    content = content.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');

    // 4) Basic segmentation into paragraphs + chapters and convert to safe HTML
    const lines = content.split('\n');
    const out = [];
    out.push(`<h1>${escapeHtml(title || 'Untitled')}</h1>`);
    out.push(`<div style="text-align:center;margin:18px 0 24px;"><em>From Project Gutenberg ‚Ä¢ Free eBook</em></div>`);

    let para = [];
    for (let i = 0; i < lines.length; i++){
      let ln = lines[i].replace(/\t/g,' ').trim();
      if (!ln) {
        if (para.length) { out.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
        continue;
      }

      // Detect chapter headings or short uppercase lines (common style)
      const isUpper = (ln === ln.toUpperCase() && ln.length < 120 && !/[.,]/.test(ln));
      const isChapter = /^CHAPTER|^Chapter|^BOOK\b/i.test(ln);
      if (isUpper || isChapter) {
        if (para.length) { out.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
        out.push(`<h2 class="chapter">${escapeHtml(ln)}</h2>`);
      } else {
        para.push(ln);
      }
    }
    if (para.length) out.push(`<p>${escapeHtml(para.join(' '))}</p>`);

    // Fallback: if output is tiny, show original (but we tried to strip header)
    if (out.length <= 3) {
      // just return original inside <pre> to avoid showing header markers
      return `<pre style="white-space:pre-wrap; font-family:inherit; font-size:${currentFontSize}px;">${escapeHtml(content)}</pre>`;
    }
    return out.join('\n');
  }

  // --------------- pagination using CSS columns ---------------
  function initPagination(){
    const content = document.getElementById('readerContent');
    const book = document.getElementById('bookContent');
    if (!book) return;

    // set font size
    book.style.fontSize = currentFontSize + 'px';

    // compute page (column) width = visible content width (readerContent clientWidth minus padding)
    const style = window.getComputedStyle(content);
    const padLeft = parseFloat(style.paddingLeft) || 0;
    const padRight = parseFloat(style.paddingRight) || 0;
    const pageWidth = Math.max(320, Math.floor(content.clientWidth - padLeft - padRight));

    // set column width so each column = one "page"
    content.style.columnWidth = pageWidth + 'px';
    content.style.columnGap = getComputedStyle(document.documentElement).getPropertyValue('--reader-gap') || '48px';

    // small delay for layout
    setTimeout(() => {
      totalPages = Math.max(1, Math.ceil(content.scrollWidth / pageWidth));
      currentPageIndex = Math.min(currentPageIndex, totalPages - 1);
      updatePageIndicator();
      scrollToPage(currentPageIndex);
    }, 60);
  }

  function scrollToPage(index){
    const content = document.getElementById('readerContent');
    const style = window.getComputedStyle(content);
    const padLeft = parseFloat(style.paddingLeft) || 0;
    const padRight = parseFloat(style.paddingRight) || 0;
    const pageWidth = Math.max(320, Math.floor(content.clientWidth - padLeft - padRight));
    content.scrollTo({ left: index * (pageWidth + parseFloat(getComputedStyle(content).columnGap || 48)), behavior: 'smooth' });
    currentPageIndex = index;
    updatePageIndicator();
  }

  function changePage(delta){
    const newIndex = Math.max(0, Math.min(totalPages - 1, currentPageIndex + delta));
    if (newIndex === currentPageIndex) return;
    scrollToPage(newIndex);
  }

  function updatePageIndicator(){
    const el = document.getElementById('pageIndicator');
    el.textContent = `Page ${currentPageIndex + 1} / ${totalPages}`;
  }

  function adjustFont(delta){
    currentFontSize = Math.max(14, Math.min(28, currentFontSize + delta));
    const book = document.getElementById('bookContent');
    if (book) book.style.fontSize = currentFontSize + 'px';
    // re-init pagination because size changed
    setTimeout(initPagination, 60);
  }

  function closeReader(){
    const overlay = document.getElementById('readerOverlay');
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');
    document.getElementById('readerContent').innerHTML = '';
  }

  // utilities
  function escapeHtml(s){
    return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }
  function escapeForJsWindow(url){ return url ? url.replace(/'/g,"\\'") : ''; }

  // recompute pagination on resize (debounced)
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      initPagination();
    }, 150);
  });

  // start
  window.addEventListener('load', loadBooks);
  </script>
</body>
</html>