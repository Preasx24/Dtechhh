<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gutenberg Library Reader</title>
  <style>
    /* Minimal styles kept for readability */
    body { font-family: system-ui, Arial, sans-serif; background:#f5f7fa; color:#222; margin:0; padding:20px; }
    .container { max-width:1100px; margin:0 auto; }
    header h1 { margin:0 0 6px 0; }
    .controls { display:flex; gap:12px; margin:10px 0 18px; align-items:center; }
    #searchInput { padding:8px 10px; width:320px; border-radius:6px; border:1px solid #ddd; }
    #genreFilter { padding:8px; border-radius:6px; border:1px solid #ddd; }
    .stats { margin-bottom:12px; color:#555; }
    .books-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:14px; }
    .book-card { background:#fff; border-radius:8px; padding:12px; box-shadow:0 2px 8px rgba(0,0,0,.06); display:flex; flex-direction:column; gap:8px; min-height:220px; cursor:pointer; }
    .book-cover { height:140px; border-radius:6px; background:#eee; display:flex; align-items:center; justify-content:center; font-weight:600; text-align:center; padding:10px; background-size:cover; background-position:center; color:#222; }
    .book-title { font-weight:700; font-size:15px; }
    .book-author { color:#666; font-size:13px; }
    .book-meta { color:#666; font-size:12px; margin-top:6px; }
    .read-btn { margin-top:auto; border:none; background:#2d9cdb; color:#fff; padding:8px 10px; border-radius:6px; cursor:pointer; }
    .reader-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); align-items:center; justify-content:center; z-index:999; }
    .reader-container { width:92%; max-width:960px; height:85%; background:#fff; border-radius:10px; overflow:auto; display:flex; flex-direction:column; }
    .reader-header { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid #eee; }
    .reader-content { padding:16px; overflow:auto; flex:1; }
    .loading { padding:18px; color:#666; }
    .error { color:#c0392b; padding:12px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ðŸ“š Gutenberg Library</h1>
      <div class="subtitle">Explore thousands of free classic books</div>
    </header>

    <div class="controls">
      <input type="text" id="searchInput" placeholder="Search books by title or author...">
      <select id="genreFilter">
        <option value="">All Genres</option>
      </select>
    </div>

    <div class="stats" id="stats">Loading books...</div>

    <div class="books-grid" id="booksGrid">
      <div class="loading">Loading books from data.txt...</div>
    </div>
  </div>

  <!-- Reader -->
  <div class="reader-overlay" id="readerOverlay">
    <div class="reader-container">
      <div class="reader-header">
        <div id="readerBookTitle">Loading...</div>
        <div>
          <button id="decreaseFS">A-</button>
          <button id="increaseFS">A+</button>
          <button id="closeReaderBtn">âœ• Close</button>
        </div>
      </div>
      <div class="reader-content" id="readerContent"><div class="loading">Loading book content...</div></div>
    </div>
  </div>

  <script>
  // CONFIG: set your worker URL and key
  const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your worker
  const PROXY_KEY = "dtech_secret"; // must match worker expectedKey

  let books = [];
  let currentFontSize = 18;
  window.currentBookUrl = '';

  async function loadBooks() {
    try {
      const res = await fetch('data.txt', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to fetch data.txt: ' + res.status);
      const txt = await res.text();
      parseBooks(txt);
    } catch (err) {
      console.error('loadBooks error:', err);
      document.getElementById('booksGrid').innerHTML = '<div class="error">Error loading data.txt â€” check console</div>';
      document.getElementById('stats').textContent = 'ðŸ“š 0 books loaded â€¢ Use search and filters to find books';
    }
  }

  function parseBooks(text) {
    // More robust line-by-line parser. Keeps currentGenre and collects books until separator lines.
    const lines = text.split(/\r?\n/);
    let currentGenre = '';
    let currentBook = null;
    books = [];

    for (let rawLine of lines) {
      const line = rawLine.trim();
      if (!line) continue;

      // Genre header
      if (line.includes('ðŸŽ¯ GENRE:')) {
        // like "ðŸŽ¯ GENRE: ADVENTURE (4 books)"
        const m = line.match(/ðŸŽ¯\s*GENRE:\s*([^\(]+)/i);
        if (m) currentGenre = m[1].trim();
        else currentGenre = line.split('ðŸŽ¯ GENRE:')[1]?.split('(')[0].trim() || currentGenre;
        continue;
      }

      // Book start: "ðŸ“– BOOK 1: The Adventures..."
      let bookStart = line.match(/^ðŸ“–\s*BOOK\s*\d+\s*:\s*(.+)$/i);
      if (bookStart) {
        // push previous book if any
        if (currentBook) {
          books.push(currentBook);
        }
        currentBook = { genre: currentGenre, title: bookStart[1].trim() };
        continue;
      }

      if (!currentBook) continue; // ignore lines until we hit a book start

      // Fields inside a book block
      if (line.includes('ðŸ‘¤ Author:')) {
        currentBook.author = line.split('ðŸ‘¤ Author:')[1].trim();
      } else if (line.includes('ðŸ†” ID:')) {
        currentBook.id = line.split('ðŸ†” ID:')[1].trim();
      } else if (line.includes('ðŸ“Š Downloads:')) {
        currentBook.downloads = line.split('ðŸ“Š Downloads:')[1].trim();
      } else if (line.includes('ðŸŒ Language:')) {
        currentBook.language = line.split('ðŸŒ Language:')[1].trim();
      } else if (line.includes('ðŸ–¼ï¸  Cover:') || line.includes('ðŸ–¼ï¸ Cover:')) {
        // tolerate variations
        currentBook.cover = line.split('ðŸ–¼ï¸')[1] ? line.split('ðŸ–¼ï¸')[1].replace(/^Cover:\s*/i, '').trim() : line.split('Cover:')[1]?.trim();
      } else if (line.includes('ðŸ“ Text URL:')) {
        currentBook.textUrl = line.split('ðŸ“ Text URL:')[1].trim();
      } else if (line.includes('ðŸ“„ Format:')) {
        currentBook.format = line.split('ðŸ“„ Format:')[1].trim();
      } else if (line.includes('ðŸ·ï¸  Subjects:') || line.includes('ðŸ·ï¸ Subjects:')) {
        currentBook.subjects = line.split('ðŸ·ï¸')[1] ? line.split('ðŸ·ï¸')[1].replace(/^Subjects?:\s*/i, '').trim() : '';
      } else if (line.includes('ðŸ“š Bookshelves:')) {
        currentBook.bookshelves = line.split('ðŸ“š Bookshelves:')[1].trim();
      } else if (/^-{6,}/.test(line)) {
        // separator line "-----" marks end of book block
        if (currentBook) { books.push(currentBook); currentBook = null; }
      } else {
        // some additional lines we might want to attach (ignore for now)
      }
    }

    // push last book if file ended without separator
    if (currentBook) books.push(currentBook);

    // Normalize and defaults
    books = books.map(b => ({
      title: b.title || 'Untitled',
      author: b.author || 'Unknown',
      genre: b.genre || 'Unknown',
      textUrl: b.textUrl || '',
      cover: b.cover || '',
      downloads: b.downloads || '0',
      subjects: b.subjects || '',
      id: b.id || '',
      language: b.language || '',
      bookshelves: b.bookshelves || ''
    }));

    console.log('Parsed books count:', books.length);
    if (books.length === 0) {
      console.warn('No books parsed â€” sample of first 40 chars of data.txt:', text.slice(0,40));
    }

    displayBooks(books);
    updateStats();
    populateGenres();
  }

  function displayBooks(list) {
    const grid = document.getElementById('booksGrid');
    grid.innerHTML = '';
    if (!list || list.length === 0) {
      grid.innerHTML = '<div class="no-books">No books found matching your search.</div>';
      return;
    }

    list.forEach(book => {
      const card = document.createElement('div');
      card.className = 'book-card';
      card.addEventListener('click', () => openBook(book.textUrl, book.title));

      const cover = document.createElement('div');
      cover.className = 'book-cover';
      if (book.cover) {
        // set as background image; fallback to text if image fails
        cover.style.backgroundImage = `url("${book.cover}")`;
      } else {
        cover.textContent = book.title.length > 30 ? book.title.slice(0,30) + '...' : book.title;
      }

      const t = document.createElement('div');
      t.className = 'book-title'; t.textContent = book.title;

      const a = document.createElement('div');
      a.className = 'book-author'; a.textContent = book.author;

      const meta = document.createElement('div');
      meta.className = 'book-meta';
      meta.innerHTML = `ðŸ“Š ${book.downloads} downloads<br>ðŸ·ï¸ ${book.genre}`;

      const btn = document.createElement('button');
      btn.className = 'read-btn'; btn.textContent = 'ðŸ“– Read Book';
      btn.addEventListener('click', (ev) => { ev.stopPropagation(); openBook(book.textUrl, book.title); });

      card.appendChild(cover);
      card.appendChild(t);
      card.appendChild(a);
      card.appendChild(meta);
      card.appendChild(btn);

      grid.appendChild(card);
    });
  }

  function updateStats() {
    document.getElementById('stats').textContent = `ðŸ“š ${books.length} books loaded â€¢ Use search and filters to find books`;
  }

  function populateGenres() {
    const select = document.getElementById('genreFilter');
    select.innerHTML = '<option value="">All Genres</option>';
    const unique = [...new Set(books.map(b => b.genre).filter(Boolean))].sort();
    unique.forEach(g => {
      const o = document.createElement('option'); o.value = g; o.textContent = g; select.appendChild(o);
    });
  }

  // filtering
  document.getElementById('searchInput').addEventListener('input', applyFilters);
  document.getElementById('genreFilter').addEventListener('change', applyFilters);

  function applyFilters() {
    const q = document.getElementById('searchInput').value.trim().toLowerCase();
    const genre = document.getElementById('genreFilter').value;
    const filtered = books.filter(b => {
      const matchesQ = !q || (b.title + ' ' + b.author + ' ' + (b.subjects||'')).toLowerCase().includes(q);
      const matchesGenre = !genre || b.genre === genre;
      return matchesQ && matchesGenre;
    });
    displayBooks(filtered);
  }

  // Reader controls
  document.getElementById('decreaseFS').addEventListener('click', () => changeFontSize(-1));
  document.getElementById('increaseFS').addEventListener('click', () => changeFontSize(1));
  document.getElementById('closeReaderBtn').addEventListener('click', closeReader);
  document.getElementById('readerOverlay').addEventListener('click', e => { if (e.target === e.currentTarget) closeReader(); });

  async function openBook(textUrl, title) {
    const overlay = document.getElementById('readerOverlay');
    const content = document.getElementById('readerContent');
    const titleDiv = document.getElementById('readerBookTitle');

    titleDiv.textContent = title || 'Loading...';
    overlay.style.display = 'flex';
    content.innerHTML = '<div class="loading">Loading book content...</div>';
    window.currentBookUrl = textUrl || '';

    if (!textUrl) {
      content.innerHTML = '<div class="error">No text URL available for this book.</div>';
      return;
    }

    try {
      // Build proxy request to worker
      const proxyUrl = `${PROXY_URL}?url=${encodeURIComponent(textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`;
      const resp = await fetch(proxyUrl);
      if (!resp.ok) {
        const body = await resp.text().catch(()=>'');
        throw new Error(`Proxy fetch failed: ${resp.status} ${body}`);
      }
      const text = await resp.text();
      const cleaned = cleanBookContent(text, title);
      content.innerHTML = `<div class="book-content" style="font-size:${currentFontSize}px">${cleaned}</div>`;
    } catch (err) {
      console.error('openBook error:', err);
      content.innerHTML = `<div class="error">Failed to load book: ${escapeHtml(err.message)}<br><br>
        <button onclick="window.open('${encodeURIComponent(textUrl).replace(/%20/g,' ')}','_blank')">Open original file</button>
      </div>`;
    }
  }

  function cleanBookContent(text, title) {
    let content = text || '';
    // Remove Gutenberg headers/footers (best-effort)
    const startMarkers = [
      '*** START OF THE PROJECT GUTENBERG EBOOK',
      '*** START OF THIS PROJECT GUTENBERG EBOOK',
      '***START OF THE PROJECT GUTENBERG EBOOK',
      'Produced by',
      'Transcriber'
    ];
    let startIdx = -1;
    for (const m of startMarkers) { startIdx = content.indexOf(m); if (startIdx !== -1) { content = content.substring(startIdx); break; } }

    // remove common metadata blocks
    content = content.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
    content = content.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
    content = content.replace(/Title: [\s\S]*?\n(Author: [\s\S]*?\n)?/gi, '');

    // Trim footer
    const endMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK', 'End of the Project Gutenberg'];
    for (const m of endMarkers) { const i = content.indexOf(m); if (i !== -1) { content = content.substring(0,i); break; } }

    // Convert to paragraphs / headings
    const lines = content.split(/\r?\n/);
    const out = [];
    out.push(`<h1>${escapeHtml(title || 'Untitled')}</h1>`);
    out.push('<div style="text-align:center;margin:20px 0;padding:10px;background:#f8f9fa;border-radius:8px;"><em>From Project Gutenberg â€¢ Free eBook</em></div>');

    let para = [];
    for (let ln of lines) {
      ln = ln.trim();
      if (!ln) {
        if (para.length) { out.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
        continue;
      }
      // chapter heading detection
      if ((ln === ln.toUpperCase() && ln.length < 120 && !/[.,]/.test(ln)) || ln.startsWith('CHAPTER') || ln.startsWith('Chapter')) {
        if (para.length) { out.push(`<p>${escapeHtml(para.join(' '))}</p>`); para = []; }
        out.push(`<h2>${escapeHtml(ln)}</h2>`);
      } else {
        para.push(ln);
      }
    }
    if (para.length) out.push(`<p>${escapeHtml(para.join(' '))}</p>`);

    if (out.length <= 3) {
      return `<div class="error"><p>Could not extract readable content from this book.</p>
        <p><button onclick="window.open('${window.currentBookUrl}','_blank')">Open original file</button></p></div>`;
    }
    return out.join('\n');
  }

  function escapeHtml(s) {
    return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function closeReader() {
    document.getElementById('readerOverlay').style.display = 'none';
    document.getElementById('readerContent').innerHTML = '';
  }

  function changeFontSize(delta) {
    currentFontSize = Math.max(14, Math.min(30, currentFontSize + delta));
    const c = document.querySelector('.book-content');
    if (c) c.style.fontSize = currentFontSize + 'px';
  }

  // start
  window.addEventListener('load', () => { loadBooks(); });
  </script>
</body>
</html>