<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gutenberg Library ‚Äî Paged Reader + Read Later</title>
<style>
  :root{
    --accent:#8b6b4c;
    --accent-light:#d4c4b5;
    --accent-dark:#6d533c;
    --text:#2c1810;
    --text-light:#5a4a3a;
    --muted:#9e8e7e;
    --background:#f9f5f1;
    --card-bg:#ffffff;
    --book-font: "Georgia","Times New Roman", serif;
    --reader-font-size: 9px;
    --page-words: 500;
  }

  html,body{
    height:100%;
    margin:0;
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    color:var(--text);
    background:var(--background);
    line-height:1.5;
  }

  .topbar{
    background:var(--card-bg);
    padding:16px 24px;
    border-bottom:1px solid var(--accent-light);
    display:flex;
    align-items:center;
    justify-content:space-between;
    position:sticky;
    top:0;
    z-index:30;
    box-shadow:0 2px 10px rgba(0,0,0,0.05);
  }

  .brand{
    font-weight:700;
    font-size:22px;
    color:var(--accent-dark);
    display:flex;
    align-items:center;
    gap:10px;
  }

  .brand-icon{
    font-size:24px;
  }

  .tabs{
    display:flex;
    gap:4px;
    background:var(--accent-light);
    padding:4px;
    border-radius:12px;
  }

  .tab{
    padding:10px 20px;
    border-radius:8px;
    background:transparent;
    color:var(--text-light);
    cursor:pointer;
    font-weight:500;
    transition:all 0.2s ease;
  }

  .tab.active{
    background:var(--accent-dark);
    color:#fff;
  }

  .search-row{
    display:flex;
    gap:12px;
    align-items:center;
    padding:20px 24px;
    background:var(--card-bg);
    border-bottom:1px solid var(--accent-light);
  }

  #searchInput{
    padding:12px 16px;
    border-radius:10px;
    border:1px solid var(--accent-light);
    flex:1;
    max-width:500px;
    font-size:16px;
    background:var(--background);
    transition:all 0.2s ease;
  }

  #searchInput:focus{
    outline:none;
    border-color:var(--accent);
    box-shadow:0 0 0 3px rgba(139, 107, 76, 0.1);
  }

  #genreFilter{
    padding:12px 16px;
    border-radius:10px;
    border:1px solid var(--accent-light);
    background:var(--background);
    font-size:16px;
    min-width:200px;
  }

  .layout{
    max-width:1400px;
    margin:24px auto;
    padding:0 20px;
  }

  .stats{
    color:var(--muted);
    margin:12px 0 20px;
    font-size:15px;
  }

  .loading-progress {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
    padding: 10px;
    background: rgba(139, 107, 76, 0.1);
    border-radius: 8px;
  }

  .progress-bar {
    flex: 1;
    height: 8px;
    background: #e0d5c5;
    border-radius: 4px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: #8b6b4c;
    border-radius: 4px;
    transition: width 0.3s ease;
  }

  .progress-text {
    font-size: 14px;
    color: #6d533c;
    min-width: 120px;
    text-align: right;
  }

  /* Home Page Design - Compact Two-Column Layout */
  #homeSection {
    background: linear-gradient(135deg, #f9f5f1 0%, #e8dfd3 100%);
    padding: 25px;
    border-radius: 16px;
    margin-bottom: 30px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
    border: 1px solid #e0d5c5;
  }

  #homeSection .section-title {
    color: #8b6b4c;
    border-bottom: 2px solid #d4c4b5;
    padding-bottom: 12px;
    font-size: 28px;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 25px;
  }

  #homeSection .section-title:before {
    content: "üìö";
    font-size: 32px;
  }

  .genre-section {
    margin-bottom: 35px;
    background: rgba(255,255,255,0.7);
    padding: 18px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    border: 1px solid #e8dfd3;
  }

  .genre-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 18px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e0d5c5;
  }

  .genre-title {
    font-size: 20px;
    color: #6d533c;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .genre-count {
    background: #8b6b4c;
    color: white;
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 500;
  }

  .books-grid{
    display:grid;
    grid-template-columns:repeat(2, 1fr); /* Two columns */
    gap: 15px;
    margin-bottom: 20px;
  }

  .book-card{
    background:var(--card-bg);
    border-radius:10px;
    padding:14px;
    box-shadow:0 3px 10px rgba(0,0,0,0.06);
    display:flex;
    flex-direction:column;
    gap:10px;
    min-height:200px;
    transition:all 0.3s ease;
    border:1px solid transparent;
    cursor:pointer;
    position: relative;
    overflow: hidden;
  }

  .book-card:hover{
    transform:translateY(-3px);
    box-shadow:0 6px 15px rgba(0,0,0,0.1);
    border-color:var(--accent-light);
  }

  .book-card:before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #8b6b4c, #d4c4b5);
  }

  .cover-wrap{
    height:120px;
    border-radius:6px;
    overflow:hidden;
    background:#f3f3f3;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    box-shadow:0 3px 6px rgba(0,0,0,0.1);
  }

  .cover-wrap img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }

  .cover-placeholder{
    padding:6px;
    text-align:center;
    font-weight:700;
    color:#333;
    font-size: 13px;
  }

  .book-title{
    font-weight:700;
    font-size:14px;
    line-height:1.3;
    color:var(--text);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .book-author{
    color:var(--muted);
    font-size:12px;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .book-genre{
    color:var(--accent);
    font-size:11px;
    font-weight:500;
    margin-top:2px;
  }

  .card-row{
    display:flex;
    gap:6px;
    align-items:center;
    margin-top:auto;
  }

  .btn{
    padding:8px 12px;
    border-radius:6px;
    border:none;
    background:var(--accent);
    color:#fff;
    cursor:pointer;
    font-weight:500;
    transition:all 0.2s ease;
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:4px;
    font-size: 13px;
  }

  .btn:hover{
    background:var(--accent-dark);
    transform:translateY(-1px);
  }

  .btn.secondary{
    background:var(--accent-light);
    color:var(--text);
  }

  .small-btn{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid var(--accent-light);
    background:#fff;
    cursor:pointer;
    font-size:12px;
    transition:all 0.2s ease;
  }

  .small-btn:hover{
    background:var(--accent-light);
  }

  .load-more-btn {
    background: #8b6b4c;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    display: block;
    margin: 0 auto;
    transition: all 0.2s ease;
    font-size: 14px;
  }

  .load-more-btn:hover {
    background: #6d533c;
    transform: translateY(-2px);
  }

  .load-more-genres-btn {
    background: #8b6b4c;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    display: block;
    margin: 20px auto 0;
    transition: all 0.2s ease;
    font-size: 16px;
  }

  .load-more-genres-btn:hover {
    background: #6d533c;
    transform: translateY(-2px);
  }

  /* Continue Reading Section - Modern Progress Design */
  #continueSection {
    background: linear-gradient(135deg, #f0f7f0 0%, #d9ead9 100%);
    padding: 30px;
    border-radius: 16px;
    margin-bottom: 30px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
    border: 1px solid #c8d9c8;
  }

  #continueSection .section-title {
    color: #2d5a2d;
    border-bottom: 2px solid #a8c8a8;
    padding-bottom: 12px;
    font-size: 28px;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 25px;
  }

  #continueSection .section-title:before {
    content: "‚è±Ô∏è";
    font-size: 32px;
  }

  .continue-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 25px;
  }

  .continue-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.07);
    display: flex;
    flex-direction: column;
    gap: 15px;
    transition: all 0.3s ease;
    border-left: 4px solid #4a8c4a;
    position: relative;
  }

  .continue-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.1);
  }

  .continue-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  .continue-title {
    font-size: 18px;
    font-weight: 700;
    color: #2d5a2d;
    margin: 0;
    flex: 1;
  }

  .continue-date {
    font-size: 12px;
    color: #7a9c7a;
    background: #e8f3e8;
    padding: 4px 8px;
    border-radius: 12px;
    white-space: nowrap;
  }

  .continue-author {
    color: #7a9c7a;
    font-size: 14px;
    margin-top: -10px;
  }

  .progress-container {
    margin: 10px 0;
  }

  .progress-info {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #7a9c7a;
    margin-bottom: 5px;
  }

  .progress-bar {
    height: 6px;
    background: #e0e0e0;
    border-radius: 3px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4a8c4a, #6bb46b);
    border-radius: 3px;
  }

  .continue-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  .continue-btn {
    flex: 1;
    background: #4a8c4a;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .continue-btn:hover {
    background: #3a7a3a;
  }

  .remove-btn {
    background: #f5f5f5;
    color: #7a7a7a;
    border: 1px solid #e0e0e0;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .remove-btn:hover {
    background: #e8e8e8;
  }

  /* Read Later Section - Collection Design */
  #readLaterSection {
    background: linear-gradient(135deg, #f9f1f1 0%, #f0e0e0 100%);
    padding: 30px;
    border-radius: 16px;
    margin-bottom: 30px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
    border: 1px solid #e8d5d5;
  }

  #readLaterSection .section-title {
    color: #8c4a4a;
    border-bottom: 2px solid #d4b8b8;
    padding-bottom: 12px;
    font-size: 28px;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 25px;
  }

  #readLaterSection .section-title:before {
    content: "üìå";
    font-size: 32px;
  }

  .readlater-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 25px;
  }

  .readlater-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.07);
    display: flex;
    flex-direction: column;
    gap: 15px;
    transition: all 0.3s ease;
    border-top: 4px solid #d4b8b8;
    position: relative;
  }

  .readlater-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.1);
  }

  .readlater-card:before {
    content: "‚òÖ";
    position: absolute;
    top: -10px;
    right: 15px;
    background: #8c4a4a;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
  }

  .readlater-cover {
    height: 120px;
    border-radius: 8px;
    overflow: hidden;
    background: #f3f3f3;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .readlater-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .readlater-info {
    flex: 1;
  }

  .readlater-title {
    font-size: 16px;
    font-weight: 700;
    color: #8c4a4a;
    margin: 0 0 5px 0;
  }

  .readlater-author {
    color: #9e7e7e;
    font-size: 14px;
    margin: 0;
  }

  .readlater-date {
    font-size: 12px;
    color: #b8a0a0;
    margin-top: 8px;
  }

  .readlater-actions {
    display: flex;
    gap: 10px;
  }

  .readlater-open {
    flex: 1;
    background: #8c4a4a;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .readlater-open:hover {
    background: #7a3a3a;
  }

  .readlater-remove {
    background: #f5f5f5;
    color: #7a7a7a;
    border: 1px solid #e0e0e0;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .readlater-remove:hover {
    background: #e8e8e8;
  }

  /* Page reader - FULLSCREEN */
  .reader-fullscreen{
    display:none;
    position:fixed;
    inset:0;
    background:#f5f1ea;
    color:var(--text);
    z-index:9999;
    overflow:hidden;
    font-family:var(--book-font);
  }

  .reader-header{
    height:0;
    padding:0;
    overflow:hidden;
  }

  .reader-title{
    font-weight:700;
    font-family:var(--book-font);
    font-size:18px;
    max-width:50%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    color:var(--accent-dark);
  }

  .reader-body{
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#f5f1ea;
    position:relative;
  }

  .page-container{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
    padding:20px;
    max-width:1000px;
    margin:0 auto;
  }

  .page{
    width:100%;
    height:100%;
    background:#fff;
    border-radius:4px;
    box-shadow:0 10px 30px rgba(0,0,0,0.1);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    position:relative;
    border:1px solid #e6dfd5;
  }

  .page-content{
    flex:1;
    overflow:hidden;
    font-family:var(--book-font);
    font-size:var(--reader-font-size);
    line-height:1.6;
    text-align:justify;
    padding:40px;
    hyphens:auto;
    height:100%;
    box-sizing:border-box;
  }

  .page-content h1{
    font-size:20px;
    text-align:center;
    margin:10px 0;
    color:var(--accent-dark);
  }

  .page-content h2.chapter{
    font-size:16px;
    text-align:center;
    margin:20px 0;
    color:var(--accent);
  }

  .page-content p{
    margin:0 0 12px;
    text-indent:1.5em;
  }

  .page-content p:first-child{
    text-indent:0;
  }

  .reader-footer{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    justify-content:center;
    align-items:center;
    pointer-events:none;
    opacity:1;
    transition:opacity 0.5s ease;
  }

  .reader-footer.hidden{
    opacity:0;
  }

  .page-indicator{
    background:rgba(0,0,0,0.7);
    padding:8px 16px;
    border-radius:20px;
    font-size:14px;
    color:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,0.2);
  }

  .nav-hit-left,.nav-hit-right{
    position:absolute;
    top:0;
    bottom:0;
    width:40%;
    pointer-events:auto;
    z-index:10;
    cursor:pointer;
  }

  .nav-hit-left{
    left:0;
  }

  .nav-hit-right{
    right:0;
  }

  .nav-arrow{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    background:rgba(255,255,255,0.8);
    width:50px;
    height:50px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:20px;
    color:var(--accent);
    box-shadow:0 4px 12px rgba(0,0,0,0.1);
    opacity:0;
    transition:opacity 0.3s ease;
  }

  .nav-hit-left:hover .nav-arrow-left,
  .nav-hit-right:hover .nav-arrow-right{
    opacity:1;
  }

  .nav-arrow-left{
    left:20px;
  }

  .nav-arrow-right{
    right:20px;
  }

  /* small screens */
  @media (max-width:768px){
    .page-container{
      padding:10px;
    }
    
    .page-content{
      padding:30px;
    }
    
    .topbar{
      flex-direction:column;
      gap:15px;
      padding:15px;
    }
    
    .tabs{
      width:100%;
      justify-content:center;
    }
    
    .search-row{
      flex-direction:column;
      align-items:stretch;
    }
    
    #searchInput, #genreFilter{
      max-width:none;
    }
    
    .books-grid{
      grid-template-columns:1fr; /* Single column on mobile */
    }
    
    .nav-hit-left, .nav-hit-right{
      width:30%;
    }
  }

  /* lists for Continue/Read Later */
  .list-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(260px,1fr));
    gap:20px;
  }

  .empty-note{
    color:var(--muted);
    padding:40px 20px;
    background:var(--card-bg);
    border-radius:12px;
    text-align:center;
    font-size:16px;
  }

  .section-title{
    font-size:24px;
    margin:0 0 20px;
  }

  /* Toast notification */
  .toast{
    position:fixed;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    background:var(--accent-dark);
    color:#fff;
    padding:12px 20px;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:10000;
    font-weight:500;
  }
</style>
</head>
<body>

<!-- Top -->
<div class="topbar">
  <div class="brand">
    <span class="brand-icon">üìö</span>
    <span>Library</span>
  </div>
  <div class="tabs" role="tablist" aria-label="Sections">
    <div class="tab active" id="tab-home">Home</div>
    <div class="tab" id="tab-continue">Continue</div>
    <div class="tab" id="tab-readlater">Read Later</div>
  </div>
</div>

<!-- search/filters -->
<div class="search-row">
  <input id="searchInput" placeholder="Search by title, author, or subject..." />
  <select id="genreFilter"><option value="">All Genres</option></select>
</div>

<!-- main content -->
<div class="layout" id="layout">
  <div id="homeSection">
    <h2 class="section-title">Browse Collection</h2>
    <div class="stats" id="stats">Loading books...</div>
    <div id="loadingProgress" class="loading-progress" style="display: none;">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
      <div class="progress-text" id="progressText">Loading...</div>
    </div>
    <div id="homeContent"></div>
    <button id="loadMoreGenres" class="load-more-genres-btn" style="display:none">Load More Genres</button>
  </div>

  <div id="continueSection" style="display:none">
    <h2 class="section-title">Continue Reading</h2>
    <div id="continueList" class="continue-grid"></div>
    <div id="continueEmpty" class="empty-note" style="display:none">Nothing to continue ‚Äî open a book and it will appear here.</div>
  </div>

  <div id="readLaterSection" style="display:none">
    <h2 class="section-title">Read Later</h2>
    <div id="readLaterList" class="readlater-grid"></div>
    <div id="readLaterEmpty" class="empty-note" style="display:none">No saved books ‚Äî add some using the "Read Later" button on a book card.</div>
  </div>
</div>

<!-- Reader fullscreen -->
<div class="reader-fullscreen" id="reader">
  <div class="reader-header">
    <div class="reader-title" id="readerTitle">Loading...</div>
  </div>

  <div class="reader-body">
    <div class="page-container" id="pageContainer">
      <div class="page">
        <div class="page-content" id="pageContent">Loading...</div>
      </div>
    </div>

    <div class="nav-hit-left" id="navLeft">
      <div class="nav-arrow nav-arrow-left">‚óÄ</div>
    </div>
    <div class="nav-hit-right" id="navRight">
      <div class="nav-arrow nav-arrow-right">‚ñ∂</div>
    </div>

    <div class="reader-footer" id="readerFooter">
      <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
    </div>
  </div>
</div>

<script>
/* CONFIG - EASILY EDITABLE VALUES */
const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your Worker
const PROXY_KEY = "dtech_secret";
const WORDS_PER_PAGE_DEFAULT = 500;         // Change this value to adjust words per page
const MIN_BALANCE_RATIO = 0.40;             // minimum fraction for last page before rebalancing
const FONT_SIZE_DEFAULT = 9;                // Change this value to adjust font size
const BOOKS_PER_GENRE = 10;                 // Number of books to show per genre initially
const GENRES_PER_LOAD = 5;                  // Number of genres to show initially (reduced for faster loading)
const GENRES_PER_FILTER = 40;               // Number of genres to show in filter dropdown
const CHUNK_SIZE = 5000;                    // Size of data chunks to process at once

/* STATE */
let books = [];
let pages = [];            // current pages (HTML strings)
let currentPage = 0;
let currentBook = null;    // {title, textUrl, cover, author}
let wordsPerPage = WORDS_PER_PAGE_DEFAULT;
let fontSize = FONT_SIZE_DEFAULT;
let pageIndicatorTimeout;
let genreDisplayCounts = {}; // Track how many books are shown per genre
let genresToShow = GENRES_PER_LOAD; // Track how many genres to display
let rawData = ""; // Store the raw data for lazy parsing
let processedData = ""; // Store already processed data
let searchIndex = {}; // Store search index for faster searching
let isProcessing = false; // Track if we're currently processing data

/* UI refs */
const booksGrid = document.getElementById('booksGrid');
const homeContent = document.getElementById('homeContent');
const statsEl = document.getElementById('stats');
const pageContent = document.getElementById('pageContent');
const pageIndicator = document.getElementById('pageIndicator');
const readerEl = document.getElementById('reader');
const readerTitle = document.getElementById('readerTitle');
const readerFooter = document.getElementById('readerFooter');
const loadMoreGenresBtn = document.getElementById('loadMoreGenres');
const loadingProgress = document.getElementById('loadingProgress');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

/* Tabs */
const tabHome = document.getElementById('tab-home');
const tabContinue = document.getElementById('tab-continue');
const tabReadLater = document.getElementById('tab-readlater');
const homeSection = document.getElementById('homeSection');
const continueSection = document.getElementById('continueSection');
const readLaterSection = document.getElementById('readLaterSection');

tabHome.addEventListener('click', () => switchTab('home'));
tabContinue.addEventListener('click', () => switchTab('continue'));
tabReadLater.addEventListener('click', () => switchTab('readlater'));

function switchTab(id){
  tabHome.classList.remove('active'); tabContinue.classList.remove('active'); tabReadLater.classList.remove('active');
  homeSection.style.display = 'none'; continueSection.style.display = 'none'; readLaterSection.style.display = 'none';
  if (id==='home'){ tabHome.classList.add('active'); homeSection.style.display='block'; }
  if (id==='continue'){ tabContinue.classList.add('active'); continueSection.style.display='block'; renderContinueList(); }
  if (id==='readlater'){ tabReadLater.classList.add('active'); readLaterSection.style.display='block'; renderReadLaterList(); }
}

/* load data.txt and parse */
window.addEventListener('load', loadBooks);

async function loadBooks(){
  try {
    loadingProgress.style.display = 'flex';
    progressText.textContent = 'Loading data file...';
    
    const r = await fetch('data.txt', {cache:'no-store'});
    if(!r.ok) throw new Error('Failed to fetch data.txt');
    
    const reader = r.body.getReader();
    const decoder = new TextDecoder();
    let receivedLength = 0;
    let chunks = [];
    
    while(true) {
      const {done, value} = await reader.read();
      if (done) break;
      
      chunks.push(value);
      receivedLength += value.length;
      
      // Update progress
      const progressPercent = Math.min(50, (receivedLength / (2 * 1024 * 1024)) * 50); // Assume 2MB file
      progressFill.style.width = `${progressPercent}%`;
      progressText.textContent = `Loading data... ${Math.round(progressPercent)}%`;
    }
    
    rawData = chunks.map(chunk => decoder.decode(chunk)).join('');
    progressFill.style.width = '50%';
    progressText.textContent = 'Processing data...';
    
    // Start processing data in chunks
    processDataChunk();
  } catch(err){
    console.error('loadBooks', err);
    homeContent.innerHTML = '<div class="empty-note">Error loading data.txt ‚Äî open console.</div>';
    statsEl.textContent = 'üìö 0 books loaded';
    loadingProgress.style.display = 'none';
  }
}

/* Process data in chunks to avoid freezing */
function processDataChunk() {
  if (isProcessing) return;
  isProcessing = true;
  
  // If we have no processed data yet, start from the beginning
  if (processedData === "") {
    processedData = rawData;
  }
  
  // Process a chunk of data
  const chunkEnd = Math.min(CHUNK_SIZE, processedData.length);
  const chunkToProcess = processedData.substring(0, chunkEnd);
  const remainingData = processedData.substring(chunkEnd);
  
  // Parse the chunk
  parseDataChunk(chunkToProcess);
  
  // Update progress
  const progressPercent = 50 + (50 * (rawData.length - remainingData.length) / rawData.length);
  progressFill.style.width = `${progressPercent}%`;
  progressText.textContent = `Processing data... ${Math.round(progressPercent)}%`;
  
  // If there's more data to process, schedule next chunk
  if (remainingData.length > 0) {
    processedData = remainingData;
    setTimeout(() => {
      isProcessing = false;
      processDataChunk();
    }, 10); // Small delay to allow UI updates
  } else {
    // Finished processing
    loadingProgress.style.display = 'none';
    isProcessing = false;
    statsEl.textContent = `üìö ${books.length} books loaded ‚Ä¢ Use search/genre`;
    
    // Show/hide load more genres button
    const totalGenres = countGenresInData(rawData);
    if (totalGenres > genresToShow) {
      loadMoreGenresBtn.style.display = 'block';
    } else {
      loadMoreGenresBtn.style.display = 'none';
    }
  }
}

/* Parse a chunk of data.txt */
function parseDataChunk(chunk, append = false) {
  const lines = chunk.split(/\r?\n/);
  let currentGenre = '';
  let currentBook = null;
  const parsed = [];
  let bookCount = 0;
  let genreCount = 0;

  for (let raw of lines){
    const line = raw.trim();
    if (!line) continue;
    if (line.includes('üéØ GENRE:')) {
      const m = line.match(/üéØ\s*GENRE:\s*([^\(]+)/i);
      currentGenre = m ? m[1].trim() : currentGenre;
      genreCount++;
      
      // If we've reached our genre limit, stop parsing
      if (genreCount > genresToShow) {
        break;
      }
      continue;
    }
    const bs = line.match(/^üìñ\s*BOOK\s*\d+\s*:\s*(.+)$/i);
    if (bs){
      if (currentBook) {
        parsed.push(currentBook);
        bookCount++;
        
        // If we've reached our book limit, stop parsing
        if (bookCount >= BOOKS_PER_GENRE * genresToShow) {
          break;
        }
      }
      currentBook = { genre: currentGenre, title: bs[1].trim() };
      continue;
    }
    if (!currentBook) continue;
    if (line.includes('üë§ Author:')) currentBook.author = line.split('üë§ Author:')[1].trim();
    else if (line.includes('üìù Text URL:')) currentBook.textUrl = line.split('üìù Text URL:')[1].trim();
    else if (line.includes('üñºÔ∏è  Cover:') || line.includes('üñºÔ∏è Cover:')) {
      // Extract cover URL correctly
      const coverMatch = line.match(/üñºÔ∏è\s*Cover:\s*(.+)/i);
      if (coverMatch) currentBook.cover = coverMatch[1].trim();
    }
    else if (/^-{6,}/.test(line)){ 
      parsed.push(currentBook); 
      bookCount++;
      currentBook = null; 
      
      // If we've reached our book limit, stop parsing
      if (bookCount >= BOOKS_PER_GENRE * genresToShow) {
        break;
      }
    }
  }
  if (currentBook) parsed.push(currentBook);

  // If we're appending to existing books
  if (append) {
    books = books.concat(parsed);
  } else {
    books = parsed;
  }

  renderHomePage();
  populateGenreFilter();
  renderContinueList();
}

/* Count total genres in the data file */
function countGenresInData(text) {
  const lines = text.split(/\r?\n/);
  let genreCount = 0;
  
  for (let raw of lines){
    const line = raw.trim();
    if (line.includes('üéØ GENRE:')) {
      genreCount++;
    }
  }
  
  return genreCount;
}

/* Load more genres */
loadMoreGenresBtn.addEventListener('click', () => {
  genresToShow += GENRES_PER_LOAD;
  processedData = rawData; // Reset to process from beginning with new limit
  processDataChunk();
});

/* Render home page with genre sections */
function renderHomePage(list=books){
  homeContent.innerHTML = '';
  if (!list.length) { 
    homeContent.innerHTML = '<div class="empty-note">No books found.</div>'; 
    return; 
  }
  
  // Group books by genre
  const booksByGenre = {};
  list.forEach(book => {
    if (!booksByGenre[book.genre]) {
      booksByGenre[book.genre] = [];
    }
    booksByGenre[book.genre].push(book);
  });
  
  // Initialize display counts if not set
  Object.keys(booksByGenre).forEach(genre => {
    if (!genreDisplayCounts[genre]) {
      genreDisplayCounts[genre] = BOOKS_PER_GENRE;
    }
  });
  
  // Sort genres by number of books (most to least)
  const sortedGenres = Object.keys(booksByGenre).sort((a, b) => {
    return booksByGenre[b].length - booksByGenre[a].length;
  });
  
  // Create sections for each genre
  sortedGenres.forEach(genre => {
    const genreBooks = booksByGenre[genre];
    const displayCount = genreDisplayCounts[genre];
    const booksToShow = genreBooks.slice(0, displayCount);
    
    const genreSection = document.createElement('div');
    genreSection.className = 'genre-section';
    
    const genreHeader = document.createElement('div');
    genreHeader.className = 'genre-header';
    
    const genreTitle = document.createElement('div');
    genreTitle.className = 'genre-title';
    genreTitle.innerHTML = `<span>${genre}</span>`;
    
    const genreCount = document.createElement('div');
    genreCount.className = 'genre-count';
    genreCount.textContent = `${booksToShow.length} of ${genreBooks.length} books`;
    
    genreHeader.appendChild(genreTitle);
    genreHeader.appendChild(genreCount);
    genreSection.appendChild(genreHeader);
    
    const booksGrid = document.createElement('div');
    booksGrid.className = 'books-grid';
    
    booksToShow.forEach(book => {
      const card = createBookCard(book);
      booksGrid.appendChild(card);
    });
    
    genreSection.appendChild(booksGrid);
    
    // Add "Load More" button if there are more books to show
    if (displayCount < genreBooks.length) {
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.className = 'load-more-btn';
      loadMoreBtn.textContent = `Load More (${genreBooks.length - displayCount} remaining)`;
      loadMoreBtn.addEventListener('click', () => {
        genreDisplayCounts[genre] += BOOKS_PER_GENRE;
        renderHomePage(list);
      });
      genreSection.appendChild(loadMoreBtn);
    }
    
    homeContent.appendChild(genreSection);
  });
}

/* Create book card for home page */
function createBookCard(book) {
  const card = document.createElement('div'); 
  card.className='book-card';
  
  const coverWrap = document.createElement('div'); 
  coverWrap.className='cover-wrap';
  
  if (book.cover){
    const img = document.createElement('img'); 
    img.src = book.cover;
    img.alt = book.title;
    img.onload = ()=>{/* ok */};
    img.onerror = ()=>{ coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(book.title)}</div>`; };
    coverWrap.appendChild(img);
  } else {
    coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(book.title)}</div>`;
  }

  const title = document.createElement('div'); 
  title.className='book-title'; 
  title.textContent = book.title;
  
  const author = document.createElement('div'); 
  author.className='book-author'; 
  author.textContent = book.author || '';
  
  const genre = document.createElement('div'); 
  genre.className='book-genre'; 
  genre.textContent = book.genre || '';
  
  const row = document.createElement('div'); 
  row.className='card-row';

  const readBtn = document.createElement('button'); 
  readBtn.className='btn'; 
  readBtn.innerHTML = 'üìñ Read';
  readBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openBook(book); });

  const rlBtn = document.createElement('button'); 
  rlBtn.className='small-btn'; 
  rlBtn.textContent = isInReadLater(book.textUrl) ? 'Remove' : 'Read Later';
  rlBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleReadLater(book); rlBtn.textContent = isInReadLater(book.textUrl) ? 'Remove' : 'Read Later'; });

  row.appendChild(readBtn); 
  row.appendChild(rlBtn);
  card.appendChild(coverWrap); 
  card.appendChild(title); 
  card.appendChild(author); 
  card.appendChild(genre); 
  card.appendChild(row);
  
  // Clicking card reads
  card.addEventListener('click', ()=> openBook(book));
  
  return card;
}

/* helper short title */
function shortTitle(t){
  if (!t) return 'No title';
  return t.split(' ').slice(0,3).join(' ');
}

/* Genre filter / search */
function populateGenreFilter(){
  const sel = document.getElementById('genreFilter'); 
  sel.innerHTML = '<option value="">All Genres</option>';
  
  // Count books per genre
  const genreCounts = {};
  books.forEach(book => {
    if (book.genre) {
      genreCounts[book.genre] = (genreCounts[book.genre] || 0) + 1;
    }
  });
  
  // Sort genres by count (most to least)
  const sortedGenres = Object.keys(genreCounts).sort((a, b) => {
    return genreCounts[b] - genreCounts[a];
  });
  
  // Limit to top GENRES_PER_FILTER genres
  const topGenres = sortedGenres.slice(0, GENRES_PER_FILTER);
  
  // Add options with counts
  topGenres.forEach(g => { 
    const o = document.createElement('option'); 
    o.value = g; 
    o.textContent = `${g} (${genreCounts[g]})`; 
    sel.appendChild(o); 
  });
}

// Debounced search function
let searchTimeout;
document.getElementById('searchInput').addEventListener('input', (e)=>{
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    const q = e.target.value.trim().toLowerCase();
    const genre = document.getElementById('genreFilter').value;
    
    if (q.length < 2 && !genre) {
      renderHomePage();
      return;
    }
    
    // Show loading indicator for search
    loadingProgress.style.display = 'flex';
    progressFill.style.width = '0%';
    progressText.textContent = 'Searching...';
    
    // Process search in chunks to avoid freezing
    processSearch(q, genre);
  }, 300);
});

function processSearch(query, genreFilter) {
  const filtered = [];
  let processed = 0;
  const totalBooks = books.length;
  const chunkSize = 100; // Process 100 books at a time
  
  function processChunk() {
    const chunkEnd = Math.min(processed + chunkSize, totalBooks);
    
    for (let i = processed; i < chunkEnd; i++) {
      const book = books[i];
      const searchText = (book.title + ' ' + (book.author||'') + ' ' + (book.genre||'')).toLowerCase();
      
      if ((!query || searchText.includes(query)) && (!genreFilter || book.genre === genreFilter)) {
        filtered.push(book);
      }
    }
    
    processed = chunkEnd;
    
    // Update progress
    const progressPercent = (processed / totalBooks) * 100;
    progressFill.style.width = `${progressPercent}%`;
    progressText.textContent = `Searching... ${Math.round(progressPercent)}%`;
    
    if (processed < totalBooks) {
      // Process next chunk on next frame
      setTimeout(processChunk, 0);
    } else {
      // Search complete
      loadingProgress.style.display = 'none';
      renderHomePage(filtered);
      statsEl.textContent = `üìö Found ${filtered.length} books matching your search`;
    }
  }
  
  processChunk();
}

document.getElementById('genreFilter').addEventListener('change', ()=> document.getElementById('searchInput').dispatchEvent(new Event('input')));

/* READ LATER (localStorage) */
function getReadLater(){ 
  try{ 
    return JSON.parse(localStorage.getItem('gutenberg:readlater')||'[]') 
  }catch(e){ 
    return [] 
  } 
}

function saveReadLater(list){ 
  localStorage.setItem('gutenberg:readlater', JSON.stringify(list)); 
}

function isInReadLater(url){ 
  if(!url) return false; 
  return getReadLater().some(i=>i.textUrl===url); 
}

function toggleReadLater(book){
  const list = getReadLater();
  const idx = list.findIndex(b=>b.textUrl===book.textUrl);
  if (idx === -1) { 
    list.unshift({
      title:book.title, 
      author:book.author, 
      textUrl:book.textUrl, 
      cover:book.cover,
      addedDate: new Date().toISOString()
    }); 
    saveReadLater(list); 
    showToast('Added to Read Later'); 
  }
  else { 
    list.splice(idx,1); 
    saveReadLater(list); 
    showToast('Removed from Read Later'); 
  }
  renderReadLaterList();
}

/* render Read Later list */
function renderReadLaterList(){
  const wrap = document.getElementById('readLaterList');
  const empty = document.getElementById('readLaterEmpty');
  const list = getReadLater();
  wrap.innerHTML=''; 
  empty.style.display='none';
  
  if (!list.length){ 
    empty.style.display='block'; 
    return; 
  }
  
  list.forEach(b=>{
    const card = document.createElement('div');
    card.className = 'readlater-card';
    
    const coverWrap = document.createElement('div');
    coverWrap.className = 'readlater-cover';
    
    if (b.cover){ 
      const img = document.createElement('img'); 
      img.src = b.cover; 
      img.onerror = () => {
        coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
      }; 
      coverWrap.appendChild(img); 
    } else {
      coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    }
    
    const info = document.createElement('div');
    info.className = 'readlater-info';
    
    const title = document.createElement('div');
    title.className = 'readlater-title';
    title.textContent = b.title;
    
    const author = document.createElement('div');
    author.className = 'readlater-author';
    author.textContent = b.author || '';
    
    const date = document.createElement('div');
    date.className = 'readlater-date';
    date.textContent = `Added: ${formatDate(b.addedDate)}`;
    
    info.appendChild(title);
    info.appendChild(author);
    info.appendChild(date);
    
    const actions = document.createElement('div');
    actions.className = 'readlater-actions';
    
    const openBtn = document.createElement('button');
    openBtn.className = 'readlater-open';
    openBtn.textContent = 'Open';
    openBtn.addEventListener('click', () => openBook(b));
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'readlater-remove';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => { 
      toggleReadLater(b); 
      renderReadLaterList(); 
    });
    
    actions.appendChild(openBtn);
    actions.appendChild(removeBtn);
    
    card.appendChild(coverWrap);
    card.appendChild(info);
    card.appendChild(actions);
    
    wrap.appendChild(card);
  });
}

/* CONTINUE READING: scan localStorage keys for last page markers */
function getContinueList(){
  const list=[];
  for (let i=0;i<localStorage.length;i++){
    const key = localStorage.key(i);
    if (!key) continue;
    if (key.startsWith('gutenberg:lastpage:')) {
      const url = key.replace('gutenberg:lastpage:','');
      const idx = parseInt(localStorage.getItem(key),10) || 0;
      const lastRead = localStorage.getItem('gutenberg:lastread:' + url) || '';
      
      // find book meta from books[] or readLater
      let meta = books.find(b=>b.textUrl===url) || getReadLater().find(b=>b.textUrl===url) || null;
      if (meta) {
        list.push({
          title:meta.title, 
          author:meta.author, 
          textUrl:url, 
          lastPage:idx,
          lastRead: lastRead,
          totalPages: parseInt(localStorage.getItem('gutenberg:totalpages:' + url) || '1', 10)
        });
      } else {
        list.push({
          title:url.split('/').slice(-1)[0], 
          author:'', 
          textUrl:url, 
          lastPage:idx,
          lastRead: lastRead,
          totalPages: parseInt(localStorage.getItem('gutenberg:totalpages:' + url) || '1', 10)
        });
      }
    }
  }
  // sort by most recently read
  return list.sort((a, b) => new Date(b.lastRead) - new Date(a.lastRead));
}

function renderContinueList(){
  const wrap = document.getElementById('continueList');
  const empty = document.getElementById('continueEmpty');
  const list = getContinueList();
  wrap.innerHTML=''; 
  empty.style.display='none';
  
  if (!list.length){ 
    empty.style.display='block'; 
    return; 
  }
  
  list.forEach(item=>{
    const card = document.createElement('div');
    card.className = 'continue-card';
    
    const header = document.createElement('div');
    header.className = 'continue-header';
    
    const title = document.createElement('div');
    title.className = 'continue-title';
    title.textContent = item.title;
    
    const date = document.createElement('div');
    date.className = 'continue-date';
    date.textContent = item.lastRead ? formatDate(item.lastRead) : 'Unknown';
    
    header.appendChild(title);
    header.appendChild(date);
    
    const author = document.createElement('div');
    author.className = 'continue-author';
    author.textContent = item.author || '';
    
    const progressContainer = document.createElement('div');
    progressContainer.className = 'progress-container';
    
    const progressInfo = document.createElement('div');
    progressInfo.className = 'progress-info';
    progressInfo.innerHTML = `<span>Page ${item.lastPage + 1} of ${item.totalPages}</span><span>${Math.round((item.lastPage / item.totalPages) * 100)}%</span>`;
    
    const progressBar = document.createElement('div');
    progressBar.className = 'progress-bar';
    
    const progressFill = document.createElement('div');
    progressFill.className = 'progress-fill';
    progressFill.style.width = `${(item.lastPage / item.totalPages) * 100}%`;
    
    progressBar.appendChild(progressFill);
    progressContainer.appendChild(progressInfo);
    progressContainer.appendChild(progressBar);
    
    const actions = document.createElement('div');
    actions.className = 'continue-actions';
    
    const continueBtn = document.createElement('button');
    continueBtn.className = 'continue-btn';
    continueBtn.textContent = 'Continue';
    continueBtn.addEventListener('click', () => openBook({title:item.title, textUrl:item.textUrl}));
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => { 
      localStorage.removeItem('gutenberg:lastpage:' + item.textUrl);
      localStorage.removeItem('gutenberg:lastread:' + item.textUrl);
      localStorage.removeItem('gutenberg:totalpages:' + item.textUrl);
      renderContinueList(); 
    });
    
    actions.appendChild(continueBtn);
    actions.appendChild(removeBtn);
    
    card.appendChild(header);
    card.appendChild(author);
    card.appendChild(progressContainer);
    card.appendChild(actions);
    
    wrap.appendChild(card);
  });
}

/* Format date for display */
function formatDate(dateString) {
  if (!dateString) return 'Unknown';
  
  const date = new Date(dateString);
  const now = new Date();
  const diffTime = Math.abs(now - date);
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  
  if (diffDays === 0) {
    return 'Today';
  } else if (diffDays === 1) {
    return 'Yesterday';
  } else if (diffDays < 7) {
    return `${diffDays} days ago`;
  } else {
    return date.toLocaleDateString();
  }
}

/* Open book: fetch via worker, clean, paginate and render at saved page (if any) */
async function openBook(book){
  // book may be object or textUrl string
  const b = (typeof book === 'string') ? books.find(x=>x.textUrl===book) : book;
  if (!b || !b.textUrl) { alert('No text URL'); return; }
  currentBook = { title: b.title, textUrl: b.textUrl, author: b.author, cover: b.cover };

  readerTitle.textContent = currentBook.title || 'Untitled';
  showReader();

  try {
    const resp = await fetch(`${PROXY_URL}?url=${encodeURIComponent(currentBook.textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`);
    if (!resp.ok) {
      const body = await resp.text().catch(()=>resp.statusText||'');
      throw new Error('Proxy fetch failed: ' + resp.status + ' ' + body);
    }
    const raw = await resp.text();
    const plain = extractPlainText(raw);
    paginateText(plain, wordsPerPage);
    // restore last page index
    const saved = parseInt(localStorage.getItem('gutenberg:lastpage:' + currentBook.textUrl) || '0', 10);
    currentPage = Math.max(0, Math.min(saved, pages.length - 1));
    renderPage(currentPage);
    // add to "continue" automatically (localStorage lastpage will be set by renderPage)
    renderContinueList();
  } catch (err) {
    console.error('openBook error', err);
    pageContent.innerHTML = `<div style="padding:18px;color:#c0392b">Failed to load book: ${escapeHtml(err.message || err)}</div>`;
  }
}

function showReader(){ 
  readerEl.style.display='block'; 
  document.body.style.overflow='hidden'; 
  // Reset page indicator visibility
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

function hideReader(){ 
  readerEl.style.display='none'; 
  document.body.style.overflow=''; 
  renderContinueList(); 
  renderReadLaterList(); 
}

/* clean Gutenberg headers/footers and return plain text (paragraphs separated by double newline) */
function extractPlainText(raw){
  let s = (raw || '').replace(/\r\n/g, '\n');
  const U = s.toUpperCase();
  const startMarkers = ['*** START OF THE PROJECT GUTENBERG EBOOK','*** START OF THIS PROJECT GUTENBERG EBOOK','***START OF THE PROJECT GUTENBERG EBOOK','*** START'];
  let startIdx = -1;
  for (const m of startMarkers){ const i = U.indexOf(m); if (i !== -1){ startIdx = i; break; } }
  if (startIdx !== -1){
    // find next double newline after marker
    const after = s.indexOf('\n\n', startIdx);
    if (after !== -1) s = s.substring(after + 2);
    else s = s.substring(startIdx);
  } else {
    // remove typical metadata top blocks heuristically
    s = s.replace(/Title:.*\nAuthor:.*\nRelease date:.*\n/gi,'');
    s = s.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
  }

  // Remove footer/common license
  const footerMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK','*** END OF THIS PROJECT GUTENBERG EBOOK','END OF PROJECT GUTENBERG','END OF THE PROJECT GUTENBERG'];
  let endIdx = -1;
  const SU = s.toUpperCase();
  for (const fm of footerMarkers){ const i = SU.indexOf(fm); if (i !== -1){ endIdx = i; break; } }
  if (endIdx !== -1) s = s.substring(0, endIdx);

  // strip extra license paragraph remnants
  s = s.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
  // normalize repeated blank lines
  s = s.replace(/\n{3,}/g, '\n\n').trim();

  return s;
}

/* PAGINATION: Improved algorithm to prevent cutting content */
function paginateText(plain, wordsPerPageLocal){
  const paragraphs = plain.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);

  // Build pages by preserving paragraph boundaries
  const pagesArr = [];
  let currentPageText = '';
  let currentWordCount = 0;

  for (let para of paragraphs){
    const words = para.split(/\s+/).filter(Boolean);
    const paraWordCount = words.length;
    
    // If adding this paragraph would exceed the limit
    if (currentWordCount + paraWordCount > wordsPerPageLocal) {
      // If current page has content, push it
      if (currentPageText) {
        pagesArr.push(currentPageText);
        currentPageText = '';
        currentWordCount = 0;
      }
      
      // If paragraph is too long for a single page, split it
      if (paraWordCount > wordsPerPageLocal) {
        let remainingWords = paraWordCount;
        let startIdx = 0;
        
        while (remainingWords > 0) {
          const take = Math.min(remainingWords, wordsPerPageLocal);
          const chunk = words.slice(startIdx, startIdx + take).join(' ');
          pagesArr.push(chunk);
          startIdx += take;
          remainingWords -= take;
        }
      } else {
        // Paragraph fits in a new page
        currentPageText = para;
        currentWordCount = paraWordCount;
      }
    } else {
      // Add paragraph to current page
      if (currentPageText) {
        currentPageText += '\n\n' + para;
      } else {
        currentPageText = para;
      }
      currentWordCount += paraWordCount;
    }
  }
  
  // Don't forget the last page
  if (currentPageText) {
    pagesArr.push(currentPageText);
  }

  // Convert pages to HTML
  pages = pagesArr.map(pageText => {
    // Split by paragraphs and wrap each in <p> tags
    const pageParagraphs = pageText.split(/\n\s*\n/).filter(Boolean);
    return pageParagraphs.map(p => `<p>${escapeHtml(p)}</p>`).join('');
  });
  
  // Ensure non-empty
  if (!pages.length) pages = ['<p>No content extracted.</p>'];
  
  // Save total pages for progress tracking
  if (currentBook && currentBook.textUrl) {
    localStorage.setItem('gutenberg:totalpages:' + currentBook.textUrl, pages.length.toString());
  }
}

/* render a page (no horizontal scroll) */
function renderPage(idx){
  if (!pages || !pages.length) { pageContent.innerHTML = '<div class="empty-note">No pages</div>'; pageIndicator.textContent = 'Page 0 / 0'; return; }
  currentPage = Math.max(0, Math.min(idx, pages.length - 1));
  // set font size
  pageContent.style.fontSize = fontSize + 'px';
  pageContent.innerHTML = pages[currentPage];
  pageIndicator.textContent = `Page ${currentPage + 1} / ${pages.length}`;
  
  // save last page and last read timestamp
  try { 
    localStorage.setItem('gutenberg:lastpage:' + currentBook.textUrl, String(currentPage));
    localStorage.setItem('gutenberg:lastread:' + currentBook.textUrl, new Date().toISOString());
  } catch(e){}
  
  // ensure continue list refresh
  renderContinueList();
  
  // Show page indicator and set timeout to fade it
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

/* navigation handlers */
function navigatePage(direction) {
  if (direction === 'next') {
    renderPage(currentPage + 1);
  } else if (direction === 'prev') {
    renderPage(currentPage - 1);
  }
}

/* keyboard navigation */
window.addEventListener('keydown', (e)=>{
  if (readerEl.style.display === 'block'){
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { 
      navigatePage('next'); 
      e.preventDefault(); 
    }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { 
      navigatePage('prev'); 
      e.preventDefault(); 
    }
    if (e.key === 'Escape') hideReader();
  }
});

/* swipe/tap navigation areas */
let tx=0, ty=0;
function touchStart(e){ 
  const t = e.touches ? e.touches[0] : e; 
  tx = t.clientX; 
  ty = t.clientY; 
  
  // Show page indicator on touch
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
}
function touchEnd(e){ 
  const t = e.changedTouches ? e.changedTouches[0] : e; 
  const dx = t.clientX - tx; 
  const dy = t.clientY - ty; 
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30){ 
    if (dx < 0) navigatePage('next'); 
    else navigatePage('prev'); 
  }
  
  // Set timeout to hide page indicator after touch
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

document.getElementById('navLeft').addEventListener('touchstart', touchStart); 
document.getElementById('navRight').addEventListener('touchstart', touchStart);
document.getElementById('navLeft').addEventListener('touchend', touchEnd); 
document.getElementById('navRight').addEventListener('touchend', touchEnd);
document.getElementById('navLeft').addEventListener('click', ()=> navigatePage('prev')); 
document.getElementById('navRight').addEventListener('click', ()=> navigatePage('next'));

// Click anywhere on reader to show page indicator temporarily
readerEl.addEventListener('click', (e) => {
  // Don't trigger if clicking on navigation areas
  if (e.target.id !== 'navLeft' && e.target.id !== 'navRight' && 
      !e.target.closest('#navLeft') && !e.target.closest('#navRight')) {
    clearTimeout(pageIndicatorTimeout);
    readerFooter.classList.remove('hidden');
    pageIndicatorTimeout = setTimeout(() => {
      readerFooter.classList.add('hidden');
    }, 3000);
  }
});

/* CONTINUE & READ LATER helpers - after page change, these lists update */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* small toast */
function showToast(text){
  const t = document.createElement('div'); t.textContent = text; t.className = 'toast';
  document.body.appendChild(t); setTimeout(()=>t.remove(), 2000);
}

/* render both lists initially */
renderContinueList();
renderReadLaterList();

</script>
</body>
</html>
