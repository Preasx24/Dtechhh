<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gutenberg Library ‚Äî Paged Reader + Read Later</title>
<style>
  :root{
    --accent:#2d9cdb;
    --text:#111;
    --muted:#6b7280;
    --book-font: "Georgia","Times New Roman", serif;
    --reader-font-size: 12px; /* smaller by default */
    --page-words: 500;
  }

  html,body{height:100%;margin:0;font-family:system-ui, Arial, sans-serif;color:var(--text);background:#f4f6f8}
  .topbar{background:#fff;padding:12px 18px;border-bottom:1px solid #e6e9ee;display:flex;align-items:center;gap:18px;position:sticky;top:0;z-index:30}
  .brand{font-weight:700;font-size:18px}
  .tabs{display:flex;gap:8px}
  .tab{padding:8px 12px;border-radius:8px;background:transparent;color:var(--muted);cursor:pointer}
  .tab.active{background:var(--accent);color:#fff}

  .search-row{display:flex;gap:10px;align-items:center;padding:14px 18px;background:#fff;border-bottom:1px solid #e6e9ee}
  #searchInput{padding:8px;border-radius:8px;border:1px solid #ddd;width:320px}
  #genreFilter{padding:8px;border-radius:8px;border:1px solid #ddd}

  .layout{max-width:1100px;margin:18px auto;padding:0 12px}
  .stats{color:var(--muted);margin:8px 0}
  .books-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:14px}

  .book-card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(15,15,15,0.05);display:flex;flex-direction:column;gap:10px;min-height:220px}
  .cover-wrap{height:140px;border-radius:8px;overflow:hidden;background:#f3f3f3;display:flex;align-items:center;justify-content:center}
  .cover-wrap img{width:100%;height:100%;object-fit:cover;display:block}
  .cover-placeholder{padding:8px;text-align:center;font-weight:700;color:#333}
  .book-title{font-weight:700;font-size:15px}
  .book-author{color:var(--muted);font-size:13px}
  .card-row{display:flex;gap:8px;align-items:center;margin-top:auto}
  .btn{padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:#fff;cursor:pointer}
  .btn.secondary{background:#efefef;color:#333}
  .small-btn{padding:6px 8px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}

  /* Page reader - FULLSCREEN */
  .reader-fullscreen{display:none;position:fixed;inset:0;background:#fff;color:var(--text);z-index:9999;overflow:hidden}
  .reader-header{height:56px;padding:10px 14px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between}
  .reader-title{font-weight:700;font-family:var(--book-font);font-size:16px;max-width:60%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .reader-controls{display:flex;gap:8px;align-items:center}
  .reader-controls button{padding:8px 10px;border-radius:8px;border:none;background:#f3f3f3;cursor:pointer}
  .reader-body{height:calc(100% - 56px);display:flex;align-items:center;justify-content:center;background:#fff}
  .page-container{width:100%;height:100%;display:flex;align-items:flex-start;justify-content:center;box-sizing:border-box;padding:28px 48px}
  .page{width:100%;height:100%;overflow:hidden;display:flex;flex-direction:column}
  .page-content{flex:1;overflow:auto;font-family:var(--book-font);font-size:var(--reader-font-size);line-height:1.75;text-align:justify;padding-right:8px;hyphens:auto}
  .page-content h1{font-size:20px;text-align:center;margin:10px 0}
  .page-content h2.chapter{font-size:16px;text-align:center;margin:18px 0}
  .page-content p{margin:0 0 12px}
  .reader-footer{position:absolute;bottom:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:none}
  .footer-controls{pointer-events:auto;display:flex;gap:8px;align-items:center}
  .page-indicator{background:#fff;padding:6px 10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
  .nav-hit-left,.nav-hit-right{position:absolute;top:56px;bottom:0;width:30%;pointer-events:auto}

  /* small screens */
  @media (max-width:720px){
    .page-container{padding:18px}
    :root{--reader-font-size: 11px}
  }

  /* lists for Continue/Read Later */
  .list-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
  .empty-note{color:var(--muted);padding:12px;background:#fff;border-radius:8px}

</style>
</head>
<body>

<!-- Top -->
<div class="topbar">
  <div class="brand">üìö Gutenberg Library</div>
  <div class="tabs" role="tablist" aria-label="Sections">
    <div class="tab active" id="tab-home">Home</div>
    <div class="tab" id="tab-continue">Continue Reading</div>
    <div class="tab" id="tab-readlater">Read Later</div>
  </div>
</div>

<!-- search/filters -->
<div class="search-row">
  <input id="searchInput" placeholder="Search by title, author, or subject..." />
  <select id="genreFilter"><option value="">All Genres</option></select>
</div>

<!-- main content -->
<div class="layout" id="layout">
  <div id="homeSection">
    <div class="stats" id="stats">Loading books...</div>
    <div class="books-grid" id="booksGrid"><div class="loading">Loading data.txt...</div></div>
  </div>

  <div id="continueSection" style="display:none">
    <h3>Continue Reading</h3>
    <div id="continueList" class="list-grid"></div>
    <div id="continueEmpty" class="empty-note" style="display:none">Nothing to continue ‚Äî open a book and it will appear here.</div>
  </div>

  <div id="readLaterSection" style="display:none">
    <h3>Read Later</h3>
    <div id="readLaterList" class="list-grid"></div>
    <div id="readLaterEmpty" class="empty-note" style="display:none">No saved books ‚Äî add some using the "Read Later" button on a book card.</div>
  </div>
</div>

<!-- Reader fullscreen -->
<div class="reader-fullscreen" id="reader">
  <div class="reader-header">
    <div class="reader-title" id="readerTitle">Loading...</div>
    <div class="reader-controls">
      <button id="firstBtn" title="First">‚èÆ</button>
      <button id="prevBtn" title="Previous">‚óÄ</button>
      <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
      <button id="nextBtn" title="Next">‚ñ∂</button>
      <button id="lastBtn" title="Last">‚è≠</button>
      <button id="decreaseFS" title="Smaller">A-</button>
      <button id="increaseFS" title="Larger">A+</button>
      <button id="closeReader" class="primary" style="background:var(--accent);color:#fff">Close ‚úï</button>
    </div>
  </div>

  <div class="reader-body">
    <div class="page-container" id="pageContainer">
      <div class="page">
        <div class="page-content" id="pageContent">Loading...</div>
      </div>
    </div>

    <div class="nav-hit-left" id="navLeft"></div>
    <div class="nav-hit-right" id="navRight"></div>

    <div class="reader-footer">
      <div class="footer-controls">
        <button id="openOriginal">Open Original</button>
      </div>
    </div>
  </div>
</div>

<script>
/* CONFIG */
const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your Worker
const PROXY_KEY = "dtech_secret";
const WORDS_PER_PAGE_DEFAULT = 500;         // user requested default
const MIN_BALANCE_RATIO = 0.40;             // minimum fraction for last page before rebalancing

/* STATE */
let books = [];
let pages = [];            // current pages (HTML strings)
let currentPage = 0;
let currentBook = null;    // {title, textUrl, cover, author}
let wordsPerPage = WORDS_PER_PAGE_DEFAULT;
let fontSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--reader-font-size')) || 12;

/* UI refs */
const booksGrid = document.getElementById('booksGrid');
const statsEl = document.getElementById('stats');
const pageContent = document.getElementById('pageContent');
const pageIndicator = document.getElementById('pageIndicator');
const readerEl = document.getElementById('reader');
const readerTitle = document.getElementById('readerTitle');

/* Tabs */
const tabHome = document.getElementById('tab-home');
const tabContinue = document.getElementById('tab-continue');
const tabReadLater = document.getElementById('tab-readlater');
const homeSection = document.getElementById('homeSection');
const continueSection = document.getElementById('continueSection');
const readLaterSection = document.getElementById('readLaterSection');

tabHome.addEventListener('click', () => switchTab('home'));
tabContinue.addEventListener('click', () => switchTab('continue'));
tabReadLater.addEventListener('click', () => switchTab('readlater'));

function switchTab(id){
  tabHome.classList.remove('active'); tabContinue.classList.remove('active'); tabReadLater.classList.remove('active');
  homeSection.style.display = 'none'; continueSection.style.display = 'none'; readLaterSection.style.display = 'none';
  if (id==='home'){ tabHome.classList.add('active'); homeSection.style.display='block'; }
  if (id==='continue'){ tabContinue.classList.add('active'); continueSection.style.display='block'; renderContinueList(); }
  if (id==='readlater'){ tabReadLater.classList.add('active'); readLaterSection.style.display='block'; renderReadLaterList(); }
}

/* load data.txt and parse */
window.addEventListener('load', loadBooks);

async function loadBooks(){
  try {
    const r = await fetch('data.txt', {cache:'no-store'});
    if(!r.ok) throw new Error('Failed to fetch data.txt');
    const txt = await r.text();
    parseDataTxt(txt);
  } catch(err){
    console.error('loadBooks', err);
    booksGrid.innerHTML = '<div class="empty-note">Error loading data.txt ‚Äî open console.</div>';
    statsEl.textContent = 'üìö 0 books loaded';
  }
}

function parseDataTxt(text){
  const lines = text.split(/\r?\n/);
  let currentGenre = '';
  let currentBook = null;
  const parsed = [];

  for (let raw of lines){
    const line = raw.trim();
    if (!line) continue;
    if (line.includes('üéØ GENRE:')) {
      const m = line.match(/üéØ\s*GENRE:\s*([^\(]+)/i);
      currentGenre = m ? m[1].trim() : currentGenre;
      continue;
    }
    const bs = line.match(/^üìñ\s*BOOK\s*\d+\s*:\s*(.+)$/i);
    if (bs){
      if (currentBook) parsed.push(currentBook);
      currentBook = { genre: currentGenre, title: bs[1].trim() };
      continue;
    }
    if (!currentBook) continue;
    if (line.includes('üë§ Author:')) currentBook.author = line.split('üë§ Author:')[1].trim();
    else if (line.includes('üìù Text URL:')) currentBook.textUrl = line.split('üìù Text URL:')[1].trim();
    else if (line.includes('üñºÔ∏è  Cover:') || line.includes('üñºÔ∏è Cover:')) currentBook.cover = (line.split('üñºÔ∏è')[1]||'').replace(/^Cover:\s*/i,'').trim();
    else if (/^-{6,}/.test(line)){ parsed.push(currentBook); currentBook = null; }
  }
  if (currentBook) parsed.push(currentBook);

  books = parsed.map(b => ({
    title: b.title || 'Untitled',
    author: b.author || 'Unknown',
    genre: b.genre || 'Unknown',
    textUrl: b.textUrl || '',
    cover: b.cover || ''
  }));

  renderBookGrid();
  statsEl.textContent = `üìö ${books.length} books loaded ‚Ä¢ Use search/genre`;
  populateGenreFilter();
  renderContinueList();
}

/* render book grid */
function renderBookGrid(list=books){
  booksGrid.innerHTML = '';
  if (!list.length) { booksGrid.innerHTML = '<div class="empty-note">No books found.</div>'; return; }
  list.forEach(b=>{
    const card = document.createElement('div'); card.className='book-card';
    const coverWrap = document.createElement('div'); coverWrap.className='cover-wrap';
    if (b.cover){
      const img = document.createElement('img'); img.src = b.cover;
      img.alt = b.title;
      img.onload = ()=>{/* ok */};
      img.onerror = ()=>{ coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`; };
      coverWrap.appendChild(img);
    } else {
      coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    }

    const title = document.createElement('div'); title.className='book-title'; title.textContent = b.title;
    const author = document.createElement('div'); author.className='book-author'; author.textContent = b.author || '';
    const row = document.createElement('div'); row.className='card-row';

    const readBtn = document.createElement('button'); readBtn.className='btn'; readBtn.textContent='üìñ Read';
    readBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openBook(b); });

    const rlBtn = document.createElement('button'); rlBtn.className='small-btn'; rlBtn.textContent = isInReadLater(b.textUrl) ? 'Remove Read Later' : 'Read Later';
    rlBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleReadLater(b); rlBtn.textContent = isInReadLater(b.textUrl) ? 'Remove Read Later' : 'Read Later'; });

    row.appendChild(readBtn); row.appendChild(rlBtn);
    card.appendChild(coverWrap); card.appendChild(title); card.appendChild(author); card.appendChild(row);
    // Clicking card reads
    card.addEventListener('click', ()=> openBook(b));
    booksGrid.appendChild(card);
  });
}

/* helper short title */
function shortTitle(t){
  if (!t) return 'No title';
  return t.split(' ').slice(0,3).join(' ');
}

/* Genre filter / search */
function populateGenreFilter(){
  const sel = document.getElementById('genreFilter'); sel.innerHTML = '<option value="">All Genres</option>';
  const uniq = [...new Set(books.map(b=>b.genre).filter(Boolean))].sort();
  uniq.forEach(g=>{ const o=document.createElement('option'); o.value=g; o.textContent=g; sel.appendChild(o); });
}
document.getElementById('searchInput').addEventListener('input', ()=>{
  const q = document.getElementById('searchInput').value.trim().toLowerCase();
  const genre = document.getElementById('genreFilter').value;
  const filtered = books.filter(b => ((b.title + ' ' + (b.author||'') + ' ' + (b.genre||'')).toLowerCase().includes(q) && (!genre || b.genre===genre)));
  renderBookGrid(filtered);
});
document.getElementById('genreFilter').addEventListener('change', ()=> document.getElementById('searchInput').dispatchEvent(new Event('input')));

/* READ LATER (localStorage) */
function getReadLater(){ try{ return JSON.parse(localStorage.getItem('gutenberg:readlater')||'[]') }catch(e){ return [] } }
function saveReadLater(list){ localStorage.setItem('gutenberg:readlater', JSON.stringify(list)); }
function isInReadLater(url){ if(!url) return false; return getReadLater().some(i=>i.textUrl===url); }
function toggleReadLater(book){
  const list = getReadLater();
  const idx = list.findIndex(b=>b.textUrl===book.textUrl);
  if (idx === -1) { list.unshift({title:book.title, author:book.author, textUrl:book.textUrl, cover:book.cover}); saveReadLater(list); showToast('Added to Read Later'); }
  else { list.splice(idx,1); saveReadLater(list); showToast('Removed from Read Later'); }
  renderReadLaterList();
}

/* render Read Later list */
function renderReadLaterList(){
  const wrap = document.getElementById('readLaterList');
  const empty = document.getElementById('readLaterEmpty');
  const list = getReadLater();
  wrap.innerHTML=''; empty.style.display='none';
  if (!list.length){ empty.style.display='block'; return; }
  list.forEach(b=>{
    const card=document.createElement('div'); card.className='book-card';
    const coverWrap = document.createElement('div'); coverWrap.className='cover-wrap';
    if (b.cover){ const img=document.createElement('img'); img.src=b.cover; img.onerror=()=>{coverWrap.innerHTML=`<div class="cover-placeholder">${shortTitle(b.title)}</div>`}; coverWrap.appendChild(img); } else coverWrap.innerHTML=`<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    const title=document.createElement('div'); title.className='book-title'; title.textContent=b.title;
    const author=document.createElement('div'); author.className='book-author'; author.textContent=b.author||'';
    const row=document.createElement('div'); row.className='card-row';
    const openBtn=document.createElement('button'); openBtn.className='btn'; openBtn.textContent='Open'; openBtn.addEventListener('click', ()=> openBook(b));
    const removeBtn=document.createElement('button'); removeBtn.className='small-btn'; removeBtn.textContent='Remove'; removeBtn.addEventListener('click', ()=>{ toggleReadLater(b); renderReadLaterList(); });
    row.appendChild(openBtn); row.appendChild(removeBtn);
    card.appendChild(coverWrap); card.appendChild(title); card.appendChild(author); card.appendChild(row);
    wrap.appendChild(card);
  });
}

/* CONTINUE READING: scan localStorage keys for last page markers */
function getContinueList(){
  const list=[];
  for (let i=0;i<localStorage.length;i++){
    const key = localStorage.key(i);
    if (!key) continue;
    if (key.startsWith('gutenberg:lastpage:')) {
      const url = key.replace('gutenberg:lastpage:','');
      const idx = parseInt(localStorage.getItem(key),10) || 0;
      // find book meta from books[] or readLater
      let meta = books.find(b=>b.textUrl===url) || getReadLater().find(b=>b.textUrl===url) || null;
      if (meta) list.push({title:meta.title, author:meta.author, textUrl:url, lastPage:idx});
      else list.push({title:url.split('/').slice(-1)[0], author:'', textUrl:url, lastPage:idx});
    }
  }
  // sort by most recently updated? can't easily get timestamp; keep insertion order
  return list;
}

function renderContinueList(){
  const wrap = document.getElementById('continueList');
  const empty = document.getElementById('continueEmpty');
  const list = getContinueList();
  wrap.innerHTML=''; empty.style.display='none';
  if (!list.length){ empty.style.display='block'; return; }
  list.forEach(item=>{
    const card=document.createElement('div'); card.className='book-card';
    const title=document.createElement('div'); title.className='book-title'; title.textContent=item.title;
    const author=document.createElement('div'); author.className='book-author'; author.textContent=item.author||'';
    const btnRow=document.createElement('div'); btnRow.className='card-row';
    const openBtn=document.createElement('button'); openBtn.className='btn'; openBtn.textContent='Continue'; openBtn.addEventListener('click', ()=> openBook({title:item.title,textUrl:item.textUrl}));
    const removeBtn=document.createElement('button'); removeBtn.className='small-btn'; removeBtn.textContent='Remove'; removeBtn.addEventListener('click', ()=> { localStorage.removeItem('gutenberg:lastpage:' + item.textUrl); renderContinueList(); });
    btnRow.appendChild(openBtn); btnRow.appendChild(removeBtn);
    card.appendChild(title); card.appendChild(author); card.appendChild(btnRow);
    wrap.appendChild(card);
  });
}

/* Open book: fetch via worker, clean, paginate and render at saved page (if any) */
async function openBook(book){
  // book may be object or textUrl string
  const b = (typeof book === 'string') ? books.find(x=>x.textUrl===book) : book;
  if (!b || !b.textUrl) { alert('No text URL'); return; }
  currentBook = { title: b.title, textUrl: b.textUrl, author: b.author, cover: b.cover };

  readerTitle.textContent = currentBook.title || 'Untitled';
  showReader();

  try {
    const resp = await fetch(`${PROXY_URL}?url=${encodeURIComponent(currentBook.textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`);
    if (!resp.ok) {
      const body = await resp.text().catch(()=>resp.statusText||'');
      throw new Error('Proxy fetch failed: ' + resp.status + ' ' + body);
    }
    const raw = await resp.text();
    const plain = extractPlainText(raw);
    paginateText(plain, wordsPerPage);
    // restore last page index
    const saved = parseInt(localStorage.getItem('gutenberg:lastpage:' + currentBook.textUrl) || '0', 10);
    currentPage = Math.max(0, Math.min(saved, pages.length - 1));
    renderPage(currentPage);
    // add to "continue" automatically (localStorage lastpage will be set by renderPage)
    renderContinueList();
  } catch (err) {
    console.error('openBook error', err);
    pageContent.innerHTML = `<div style="padding:18px;color:#c0392b">Failed to load book: ${escapeHtml(err.message || err)}</div>`;
  }
}

function showReader(){ readerEl.style.display='block'; readerEl.focus(); document.body.style.overflow='hidden'; }
function hideReader(){ readerEl.style.display='none'; document.body.style.overflow=''; renderContinueList(); renderReadLaterList(); }

/* clean Gutenberg headers/footers and return plain text (paragraphs separated by double newline) */
function extractPlainText(raw){
  let s = (raw || '').replace(/\r\n/g, '\n');
  const U = s.toUpperCase();
  const startMarkers = ['*** START OF THE PROJECT GUTENBERG EBOOK','*** START OF THIS PROJECT GUTENBERG EBOOK','***START OF THE PROJECT GUTENBERG EBOOK','*** START'];
  let startIdx = -1;
  for (const m of startMarkers){ const i = U.indexOf(m); if (i !== -1){ startIdx = i; break; } }
  if (startIdx !== -1){
    // find next double newline after marker
    const after = s.indexOf('\n\n', startIdx);
    if (after !== -1) s = s.substring(after + 2);
    else s = s.substring(startIdx);
  } else {
    // remove typical metadata top blocks heuristically
    s = s.replace(/Title:.*\nAuthor:.*\nRelease date:.*\n/gi,'');
    s = s.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
  }

  // Remove footer/common license
  const footerMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK','*** END OF THIS PROJECT GUTENBERG EBOOK','END OF PROJECT GUTENBERG','END OF THE PROJECT GUTENBERG'];
  let endIdx = -1;
  const SU = s.toUpperCase();
  for (const fm of footerMarkers){ const i = SU.indexOf(fm); if (i !== -1){ endIdx = i; break; } }
  if (endIdx !== -1) s = s.substring(0, endIdx);

  // strip extra license paragraph remnants
  s = s.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
  // normalize repeated blank lines
  s = s.replace(/\n{3,}/g, '\n\n').trim();

  return s;
}

/* PAGINATION: paragraph-aware and rebalancing to avoid tiny final page */
function paginateText(plain, wordsPerPageLocal){
  const paragraphs = plain.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);

  // Build pages greedily by words per page but keep paragraphs intact; split large paragraphs when necessary
  const pagesArr = [];
  let current = [];
  let currentWords = 0;

  for (let para of paragraphs){
    const words = para.split(/\s+/).filter(Boolean);
    if (words.length + currentWords <= wordsPerPageLocal){
      current.push(para);
      currentWords += words.length;
    } else {
      // paragraph doesn't fit entirely
      if (words.length > wordsPerPageLocal){
        // split paragraph into word-chunks
        let idx = 0;
        if (currentWords > 0){
          // finish current page with partial of this paragraph
          const take = wordsPerPageLocal - currentWords;
          current.push(words.slice(0, take).join(' '));
          pagesArr.push(current.slice());
          current = [];
          idx = take;
        }
        // now fill full pages from remaining words
        while (idx < words.length){
          const chunk = words.slice(idx, idx + wordsPerPageLocal);
          pagesArr.push([chunk.join(' ')]);
          idx += wordsPerPageLocal;
        }
      } else {
        // finish current page, push and start new with this paragraph
        if (current.length) pagesArr.push(current.slice());
        current = [para];
        currentWords = words.length;
      }
    }
  }
  if (current.length) pagesArr.push(current.slice());

  // Now ensure last page isn't too small; if last page length < MIN_BALANCE_RATIO*wordsPerPage, rebalance with previous page
  function pageWordCount(pageParas){
    return pageParas.reduce((s,p)=>s + p.split(/\s+/).filter(Boolean).length, 0);
  }

  while (pagesArr.length >= 2){
    const last = pagesArr[pagesArr.length - 1];
    const prev = pagesArr[pagesArr.length - 2];
    const lastCount = pageWordCount(last);
    if (lastCount >= Math.floor(wordsPerPageLocal * MIN_BALANCE_RATIO)) break; // acceptable
    // need to rebalance: merge prev+last and split into two balanced pages
    const combined = prev.concat(last);
    const combinedWords = combined.join(' ').split(/\s+/).filter(Boolean);
    if (combinedWords.length <= wordsPerPageLocal) {
      // if combined fits in one page, merge into one and we're done
      pagesArr.splice(pagesArr.length - 2, 2, [combinedWords.join(' ')]);
      break;
    } else {
      // split combined into two near-equal pages
      const half = Math.ceil(combinedWords.length / 2);
      const firstChunk = combinedWords.slice(0, half).join(' ');
      const secondChunk = combinedWords.slice(half).join(' ');
      pagesArr.splice(pagesArr.length - 2, 2, [firstChunk], [secondChunk]);
      // loop to check again (maybe second is too small, but loop will handle)
    }
  }

  // Convert page arrays of paragraphs into HTML strings
  pages = pagesArr.map(pageParas => pageParas.map(p => `<p>${escapeHtml(p)}</p>`).join('\n'));
  // ensure non-empty
  if (!pages.length) pages = ['<p>No content extracted.</p>'];
}

/* render a page (no horizontal scroll) */
function renderPage(idx){
  if (!pages || !pages.length) { pageContent.innerHTML = '<div class="empty-note">No pages</div>'; pageIndicator.textContent = 'Page 0 / 0'; return; }
  currentPage = Math.max(0, Math.min(idx, pages.length - 1));
  // set font size
  pageContent.style.fontSize = fontSize + 'px';
  pageContent.innerHTML = pages[currentPage];
  pageIndicator.textContent = `Page ${currentPage + 1} / ${pages.length}`;
  // save last page
  try { localStorage.setItem('gutenberg:lastpage:' + currentBook.textUrl, String(currentPage)); } catch(e){}
  // ensure continue list refresh
  renderContinueList();
}

/* navigation handlers */
document.getElementById('nextBtn').addEventListener('click', ()=> renderPage(currentPage+1));
document.getElementById('prevBtn').addEventListener('click', ()=> renderPage(currentPage-1));
document.getElementById('firstBtn').addEventListener('click', ()=> renderPage(0));
document.getElementById('lastBtn').addEventListener('click', ()=> renderPage(pages.length-1));
document.getElementById('closeReader').addEventListener('click', ()=> hideReader());
document.getElementById('openOriginal').addEventListener('click', ()=> { if(currentBook && currentBook.textUrl) window.open(currentBook.textUrl,'_blank'); });

/* increase/decrease font size (and optionally recompute pages if you want - but we keep word-per-page const) */
document.getElementById('increaseFS').addEventListener('click', ()=>{
  fontSize = Math.min(20, fontSize + 1);
  pageContent.style.fontSize = fontSize + 'px';
});
document.getElementById('decreaseFS').addEventListener('click', ()=>{
  fontSize = Math.max(9, fontSize - 1);
  pageContent.style.fontSize = fontSize + 'px';
});

/* keyboard navigation */
window.addEventListener('keydown', (e)=>{
  if (readerEl.style.display === 'block'){
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { renderPage(currentPage + 1); e.preventDefault(); }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { renderPage(currentPage - 1); e.preventDefault(); }
    if (e.key === 'Escape') hideReader();
  }
});

/* swipe/tap navigation areas */
let tx=0, ty=0;
function touchStart(e){ const t = e.touches ? e.touches[0] : e; tx = t.clientX; ty = t.clientY; }
function touchEnd(e){ const t = e.changedTouches ? e.changedTouches[0] : e; const dx = t.clientX - tx; const dy = t.clientY - ty; if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30){ if (dx < 0) renderPage(currentPage+1); else renderPage(currentPage-1); } }
document.getElementById('navLeft').addEventListener('touchstart', touchStart); document.getElementById('navRight').addEventListener('touchstart', touchStart);
document.getElementById('navLeft').addEventListener('touchend', touchEnd); document.getElementById('navRight').addEventListener('touchend', touchEnd);
document.getElementById('navLeft').addEventListener('click', ()=> renderPage(currentPage-1)); document.getElementById('navRight').addEventListener('click', ()=> renderPage(currentPage+1));

/* CONTINUE & READ LATER helpers - after page change, these lists update */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function paginateWordsPerPage(n){ wordsPerPage = n; }

/* small toast */
function showToast(text){
  const t = document.createElement('div'); t.textContent = text;
  t.style.position='fixed'; t.style.bottom='20px'; t.style.left='50%'; t.style.transform='translateX(-50%)'; t.style.background='rgba(0,0,0,0.8)'; t.style.color='#fff'; t.style.padding='8px 12px'; t.style.borderRadius='8px'; t.style.zIndex=99999;
  document.body.appendChild(t); setTimeout(()=>t.remove(),1400);
}

/* utility for opening encoded urls safely */
function escapeForWindow(u){ return u?u.replace(/'/g,"\\'") : ''; }

/* render both lists initially */
renderContinueList();
renderReadLaterList();

</script>
</body>
</html>