<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gutenberg Library ‚Äî Reader (Paged)</title>
  <style>
    :root {
      --bg: #ffffff;
      --page-bg: #fffbe9;
      --accent: #2d9cdb;
      --text-color: #111;
      --book-font: "Georgia", "Times New Roman", serif;
      --reader-font-size: 14px; /* default smaller font to fit more words */
      --reader-gap: 0px;
    }

    /* page layout: same as before but reader touches edges and is full viewport */
    html,body { height:100%; margin:0; }
    body { font-family: system-ui, Arial, sans-serif; background:#f5f7fa; color:var(--text-color); }

    .site-container { max-width:1100px; margin:0 auto; padding:18px; }
    header h1 { margin:0 0 6px 0; }
    .controls { display:flex; gap:12px; margin:10px 0 18px; align-items:center; }
    #searchInput { padding:8px 10px; width:320px; border-radius:6px; border:1px solid #ddd; }
    #genreFilter { padding:8px; border-radius:6px; border:1px solid #ddd; }
    .stats { margin-bottom:12px; color:#555; }
    .books-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:14px; }
    .book-card { background:#fff; border-radius:8px; padding:12px; box-shadow:0 2px 8px rgba(0,0,0,.06); display:flex; flex-direction:column; gap:8px; min-height:220px; cursor:pointer; }
    .book-cover { height:140px; border-radius:6px; background:#eee; display:flex; align-items:center; justify-content:center; font-weight:600; text-align:center; padding:10px; background-size:cover; background-position:center; color:#222; }
    .book-title { font-weight:700; font-size:15px; }
    .book-author { color:#666; font-size:13px; }
    .book-meta { color:#666; font-size:12px; margin-top:6px; }
    .read-btn { margin-top:auto; border:none; background:var(--accent); color:#fff; padding:8px 10px; border-radius:6px; cursor:pointer; }

    /* FULLSCREEN READER (touches edges; no rounded corners) */
    .reader-fullscreen {
      display:none;
      position:fixed;
      inset:0;
      z-index:9999;
      background:var(--bg);
      color:var(--text-color);
      font-family: var(--book-font);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .reader-header {
      height:56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 12px;
      border-bottom:1px solid #eee;
      background:linear-gradient(180deg,#fff,#fafafa);
      box-shadow:0 1px 0 rgba(0,0,0,0.04);
    }
    .reader-title { font-weight:700; font-size:16px; max-width:70%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    .reader-controls { display:flex; gap:8px; align-items:center; }
    .reader-controls button { padding:8px 10px; border-radius:6px; border:none; background:#efefef; cursor:pointer; }
    .reader-controls button.primary { background:var(--accent); color:#fff; }

    .reader-body {
      height: calc(100% - 56px);
      display:flex;
      align-items:center;
      justify-content:center;
      background:var(--page-bg);
      overflow:hidden;
      touch-action: pan-y; /* allow vertical scroll on page if needed but we will disallow horizontal pan */
    }

    /* single page box that takes full viewport width and height minus header */
    .page-slot {
      width:100%;
      height:100%;
      padding:28px 40px; /* page inner padding */
      box-sizing:border-box;
      overflow:hidden;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }

    .page-inner {
      width:100%;
      max-width:none;
      height:100%;
      overflow:hidden;
      display:block;
    }

    /* The text area - we render the current page content here */
    .page-text {
      font-size: var(--reader-font-size);
      line-height:1.75;
      hyphens:auto;
      color:var(--text-color);
      text-align:justify;
      height:100%;
      overflow:auto; /* vertical scroll inside a page allowed only if content slightly overflows */
      padding-right:6px;
      -webkit-overflow-scrolling:touch;
    }

    .page-text h1 { text-align:center; margin:6px 0 14px; font-size:20px; }
    .page-text h2.chapter { text-align:center; margin:18px 0 12px; font-size:16px; }
    .page-text p { margin:0 0 12px; }

    /* page footer for small controls (mobile) */
    .reader-footer {
      position:absolute;
      bottom:12px;
      left:12px;
      right:12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      pointer-events:none; /* buttons will override to allow clicks */
    }

    .footer-controls { pointer-events:auto; display:flex; gap:8px; }
    .page-indicator { font-size:14px; color:#333; padding:6px 10px; background:#fff; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,0.06); }

    /* Prev/Next large hit areas left/right for swipe/tap (invisible) */
    .nav-hit-left, .nav-hit-right {
      position:absolute;
      top:56px;
      bottom:0;
      width:20%;
      pointer-events:auto;
    }
    .nav-hit-left { left:0; }
    .nav-hit-right { right:0; }

    /* small-screen adjustments */
    @media (max-width:800px) {
      .page-slot { padding:18px; }
      :root { --reader-font-size:13px; }
    }
  </style>
</head>
<body>
  <div class="site-container">
    <header>
      <h1>üìö Gutenberg Library</h1>
      <div class="subtitle">Explore thousands of free classic books</div>
    </header>

    <div class="controls">
      <input type="text" id="searchInput" placeholder="Search books by title or author...">
      <select id="genreFilter">
        <option value="">All Genres</option>
      </select>
    </div>

    <div class="stats" id="stats">Loading books...</div>
    <div class="books-grid" id="booksGrid"><div class="loading">Loading books from data.txt...</div></div>
  </div>

  <!-- FULLSCREEN READER -->
  <div class="reader-fullscreen" id="readerFullscreen" aria-hidden="true">
    <div class="reader-header">
      <div class="reader-title" id="readerTitle">Loading...</div>
      <div class="reader-controls">
        <button id="firstPageBtn" title="First">‚èÆ</button>
        <button id="prevBtn" title="Previous (Left arrow)">‚óÄ</button>
        <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
        <button id="nextBtn" title="Next (Right arrow)">‚ñ∂</button>
        <button id="lastPageBtn" title="Last">‚è≠</button>
        <button id="decreaseFS" title="Smaller text">A-</button>
        <button id="increaseFS" title="Larger text">A+</button>
        <button id="closeReaderBtn" class="primary" title="Close reader">Close ‚úï</button>
      </div>
    </div>

    <div class="reader-body" id="readerBody" role="document">
      <div class="page-slot">
        <div class="page-inner">
          <div class="page-text" id="pageText" tabindex="0">Loading...</div>
        </div>
      </div>

      <!-- invisible hit areas to tap for prev/next -->
      <div class="nav-hit-left" id="navLeft"></div>
      <div class="nav-hit-right" id="navRight"></div>

      <div class="reader-footer">
        <div class="footer-controls" style="pointer-events:auto;">
          <button id="openOriginalBtn" title="Open original">Open original</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* ================= CONFIG ================= */
  const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // <-- your worker
  const PROXY_KEY = "dtech_secret"; // <-- your worker key
  const WORDS_PER_PAGE = 300; // fixed words per page as requested
  /* ========================================== */

  // site state
  let books = [];
  let currentBook = null;          // {title, textUrl, id}
  let pages = [];                  // array of page strings (each page is HTML-ready)
  let currentPage = 0;
  let fontSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--reader-font-size')) || 14;

  // UI refs
  const reader = document.getElementById('readerFullscreen');
  const readerTitle = document.getElementById('readerTitle');
  const pageText = document.getElementById('pageText');
  const pageIndicator = document.getElementById('pageIndicator');

  // -------------- load & parse data.txt (same approach) --------------
  async function loadBooks() {
    try {
      const res = await fetch('data.txt', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to fetch data.txt: ' + res.status);
      const txt = await res.text();
      parseBooks(txt);
    } catch (err) {
      console.error('loadBooks error:', err);
      document.getElementById('booksGrid').innerHTML = '<div class="error">Error loading data.txt ‚Äî check console</div>';
      document.getElementById('stats').textContent = 'üìö 0 books loaded';
    }
  }

  function parseBooks(text) {
    const lines = text.split(/\r?\n/);
    let currentGenre = '';
    let currentBook = null;
    books = [];

    for (let raw of lines) {
      const line = raw.trim();
      if (!line) continue;
      if (line.includes('üéØ GENRE:')) {
        const m = line.match(/üéØ\s*GENRE:\s*([^\(]+)/i);
        currentGenre = m ? m[1].trim() : currentGenre;
        continue;
      }

      let start = line.match(/^üìñ\s*BOOK\s*\d+\s*:\s*(.+)$/i);
      if (start) {
        if (currentBook) books.push(currentBook);
        currentBook = { genre: currentGenre, title: start[1].trim() };
        continue;
      }
      if (!currentBook) continue;
      if (line.includes('üë§ Author:')) currentBook.author = line.split('üë§ Author:')[1].trim();
      else if (line.includes('üìù Text URL:')) currentBook.textUrl = line.split('üìù Text URL:')[1].trim();
      else if (line.includes('üñºÔ∏è  Cover:') || line.includes('üñºÔ∏è Cover:')) currentBook.cover = (line.split('üñºÔ∏è')[1]||'').replace(/^Cover:\s*/i,'').trim();
      else if (/^-{6,}/.test(line)) { books.push(currentBook); currentBook = null; }
    }
    if (currentBook) books.push(currentBook);

    books = books.map(b => ({
      title: b.title || 'Untitled',
      author: b.author || 'Unknown',
      genre: b.genre || 'Unknown',
      textUrl: b.textUrl || '',
      cover: b.cover || ''
    }));

    displayBooks(books);
    document.getElementById('stats').textContent = `üìö ${books.length} books loaded`;
    populateGenres();
  }

  function displayBooks(list) {
    const grid = document.getElementById('booksGrid');
    grid.innerHTML = '';
    if (!list || list.length === 0) { grid.innerHTML = '<div class="no-books">No books found.</div>'; return; }

    list.forEach(book => {
      const card = document.createElement('div');
      card.className = 'book-card';
      card.addEventListener('click', () => openBook(book.textUrl, book.title));

      const cover = document.createElement('div'); cover.className = 'book-cover';
      if (book.cover) { cover.style.backgroundImage = `url("${book.cover}")`; } else { cover.textContent = book.title.substring(0,32); }
      const t = document.createElement('div'); t.className = 'book-title'; t.textContent = book.title;
      const a = document.createElement('div'); a.className = 'book-author'; a.textContent = book.author || '';
      const btn = document.createElement('button'); btn.className = 'read-btn'; btn.textContent = 'üìñ Read Book';
      btn.addEventListener('click', (e) => { e.stopPropagation(); openBook(book.textUrl, book.title); });

      card.appendChild(cover); card.appendChild(t); card.appendChild(a); card.appendChild(btn);
      grid.appendChild(card);
    });
  }

  function populateGenres() {
    const sel = document.getElementById('genreFilter');
    sel.innerHTML = '<option value="">All Genres</option>';
    const uniq = [...new Set(books.map(b => b.genre).filter(Boolean))].sort();
    uniq.forEach(g => { const o = document.createElement('option'); o.value = g; o.textContent = g; sel.appendChild(o); });
  }

  document.getElementById('searchInput').addEventListener('input', () => {
    const q = document.getElementById('searchInput').value.trim().toLowerCase();
    const filtered = books.filter(b => (b.title + ' ' + (b.author||'') + ' ' + (b.genre||'')).toLowerCase().includes(q));
    displayBooks(filtered);
  });

  document.getElementById('genreFilter').addEventListener('change', () => {
    const g = document.getElementById('genreFilter').value;
    const filtered = g ? books.filter(b => b.genre === g) : books;
    displayBooks(filtered);
  });

  // --------------- OPEN BOOK -> fetch via worker, clean, paginate ---------------
  async function openBook(textUrl, title) {
    if (!textUrl) { alert('No text URL for this book'); return; }
    currentBook = { title, textUrl };
    readerTitle.textContent = title || 'Untitled';
    showReader();

    try {
      const proxyFetchUrl = `${PROXY_URL}?url=${encodeURIComponent(textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`;
      const res = await fetch(proxyFetchUrl);
      if (!res.ok) {
        const errText = await res.text().catch(()=>res.statusText||'');
        throw new Error(`Proxy fetch failed: ${res.status} ${errText}`);
      }
      const raw = await res.text();
      const plain = extractPlainText(raw); // returns cleaned plain text
      paginateFromPlain(plain);
      currentPage = loadLastPageIndex(currentBook.textUrl) || 0;
      renderPage(currentPage);
      saveLastPageIndex(currentBook.textUrl, currentPage);
    } catch (err) {
      console.error('openBook error', err);
      pageText.innerHTML = `<div style="padding:18px;color:#c0392b">Failed to load book: ${escapeHtml(err.message || err)}</div>
        <div style="margin-top:12px"><button onclick="window.open('${escapeForWindow(currentBook.textUrl)}','_blank')">Open original</button></div>`;
    }
  }

  // show/hide reader
  function showReader() {
    reader.style.display = 'block';
    reader.setAttribute('aria-hidden','false');
    document.body.style.overflow = 'hidden';
  }
  function hideReader() {
    reader.style.display = 'none';
    reader.setAttribute('aria-hidden','true');
    document.body.style.overflow = '';
  }

  // extract plain text after headers / before footers
  function extractPlainText(raw) {
    let content = (raw || '').replace(/\r\n/g, '\n');

    // find common START marker location (case-insensitive)
    const U = content.toUpperCase();
    const startMarkers = [
      '*** START OF THE PROJECT GUTENBERG EBOOK',
      '*** START OF THIS PROJECT GUTENBERG EBOOK',
      '***START OF THE PROJECT GUTENBERG EBOOK',
      '*** START'
    ];

    let sIdx = -1;
    for (const m of startMarkers) {
      sIdx = U.indexOf(m);
      if (sIdx !== -1) {
        // move past the marker line and the immediate blank line
        const after = content.indexOf('\n\n', sIdx);
        if (after !== -1) { content = content.substring(after + 2); } else { content = content.substring(sIdx + m.length); }
        break;
      }
    }

    // remove common Gutenberg header blocks if still present
    content = content.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
    content = content.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
    content = content.replace(/Title:.*\nAuthor:.*\nRelease date:.*\n/gi, '');

    // strip footer markers
    const footerMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK', '*** END OF THIS PROJECT GUTENBERG EBOOK', 'END OF THE PROJECT GUTENBERG'];
    for (const fm of footerMarkers) {
      const f = content.toUpperCase().indexOf(fm);
      if (f !== -1) { content = content.substring(0, f); break; }
    }

    // normalize spacing and trim
    content = content.replace(/\n{3,}/g, '\n\n').trim();

    return content;
  }

  // paginate by words while keeping paragraph boundaries
  function paginateFromPlain(plainText) {
    // split paragraphs by double newlines
    const paragraphs = plainText.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);

    const pagesArr = [];
    let currentPageParas = [];
    let currentCount = 0;

    for (let para of paragraphs) {
      // convert internal newlines to spaces (preserve single paragraph)
      let words = para.split(/\s+/).filter(Boolean);
      if (currentCount + words.length <= WORDS_PER_PAGE) {
        currentPageParas.push(para);
        currentCount += words.length;
      } else {
        // if paragraph alone exceeds page size, need to split it
        if (words.length > WORDS_PER_PAGE) {
          // fill remaining space on current page
          let idx = 0;
          if (currentCount > 0) {
            const take = WORDS_PER_PAGE - currentCount;
            const chunk = words.slice(0, take).join(' ');
            currentPageParas.push(chunk);
            pagesArr.push(renderParagraphsToHtml(currentPageParas));
            currentPageParas = [];
            currentCount = 0;
            idx = take;
          }
          // now split remaining words into full pages
          while (idx < words.length) {
            const chunkWords = words.slice(idx, idx + WORDS_PER_PAGE);
            pagesArr.push(renderParagraphsToHtml([chunkWords.join(' ')]));
            idx += WORDS_PER_PAGE;
          }
        } else {
          // finalize current page and start new one with this paragraph
          if (currentPageParas.length) {
            pagesArr.push(renderParagraphsToHtml(currentPageParas));
          }
          currentPageParas = [para];
          currentCount = words.length;
        }
      }
    }

    // push the last page if any
    if (currentPageParas.length) {
      pagesArr.push(renderParagraphsToHtml(currentPageParas));
    }

    pages = pagesArr;
    // apply default font size
    document.documentElement.style.setProperty('--reader-font-size', fontSize + 'px');
  }

  // turn array of paragraphs into HTML string (escape)
  function renderParagraphsToHtml(paras) {
    return paras.map(p => `<p>${escapeHtml(p.replace(/\n/g,' '))}</p>`).join('\n');
  }

  // render a specific page (no scrolling horizontally)
  function renderPage(index) {
    if (!pages || pages.length === 0) {
      pageText.innerHTML = '<div style="padding:18px;color:#666">No readable pages available.</div>';
      pageIndicator.textContent = 'Page 0 / 0';
      return;
    }
    currentPage = Math.max(0, Math.min(index, pages.length - 1));
    pageText.innerHTML = pages[currentPage];
    pageIndicator.textContent = `Page ${currentPage + 1} / ${pages.length}`;
    // save resume point
    saveLastPageIndex(currentBook.textUrl, currentPage);
    // focus for keyboard navigation
    pageText.focus();
  }

  function nextPage() { if (currentPage < pages.length - 1) renderPage(currentPage + 1); }
  function prevPage() { if (currentPage > 0) renderPage(currentPage - 1); }
  function firstPage() { renderPage(0); }
  function lastPage() { renderPage(pages.length - 1); }

  // adjust font size (smaller default to pack words)
  document.getElementById('increaseFS').addEventListener('click', () => {
    fontSize = Math.min(24, fontSize + 1);
    document.documentElement.style.setProperty('--reader-font-size', fontSize + 'px');
    pageText.style.fontSize = fontSize + 'px';
  });
  document.getElementById('decreaseFS').addEventListener('click', () => {
    fontSize = Math.max(10, fontSize - 1);
    document.documentElement.style.setProperty('--reader-font-size', fontSize + 'px');
    pageText.style.fontSize = fontSize + 'px';
  });

  // navigation buttons
  document.getElementById('nextBtn').addEventListener('click', nextPage);
  document.getElementById('prevBtn').addEventListener('click', prevPage);
  document.getElementById('firstPageBtn').addEventListener('click', firstPage);
  document.getElementById('lastPageBtn').addEventListener('click', lastPage);
  document.getElementById('closeReaderBtn').addEventListener('click', () => { hideReader(); });

  // open original
  document.getElementById('openOriginalBtn').addEventListener('click', () => {
    if (currentBook && currentBook.textUrl) window.open(currentBook.textUrl, '_blank');
  });

  // keyboard navigation
  window.addEventListener('keydown', (e) => {
    if (reader.style.display !== 'block') return;
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { nextPage(); e.preventDefault(); }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { prevPage(); e.preventDefault(); }
    if (e.key === 'Home') { firstPage(); }
    if (e.key === 'End') { lastPage(); }
    if (e.key === 'Escape') { hideReader(); }
  });

  // touch/swipe navigation
  let touchStartX = 0;
  let touchStartY = 0;
  const swipeThreshold = 40; // px

  function onTouchStart(e) {
    const t = e.touches ? e.touches[0] : e;
    touchStartX = t.clientX;
    touchStartY = t.clientY;
  }
  function onTouchEnd(e) {
    const t = e.changedTouches ? e.changedTouches[0] : e;
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) {
      if (dx < 0) nextPage(); else prevPage();
    }
  }

  document.getElementById('navLeft').addEventListener('touchstart', onTouchStart);
  document.getElementById('navLeft').addEventListener('touchend', onTouchEnd);
  document.getElementById('navRight').addEventListener('touchstart', onTouchStart);
  document.getElementById('navRight').addEventListener('touchend', onTouchEnd);

  // allow tapping left/right on big areas too (desktop)
  document.getElementById('navLeft').addEventListener('click', prevPage);
  document.getElementById('navRight').addEventListener('click', nextPage);

  // save & restore last page per book using localStorage
  function saveLastPageIndex(bookUrl, idx) {
    try {
      if (!bookUrl) return;
      const key = `gutenberg:lastpage:${bookUrl}`;
      localStorage.setItem(key, String(idx));
    } catch (e) { /* ignore storage errors */ }
  }
  function loadLastPageIndex(bookUrl) {
    try {
      if (!bookUrl) return 0;
      const key = `gutenberg:lastpage:${bookUrl}`;
      const v = localStorage.getItem(key); return v ? parseInt(v,10) : 0;
    } catch (e) { return 0; }
  }

  // helpers
  function escapeHtml(s) { return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function escapeForWindow(u) { return u ? u.replace(/'/g,"\\'") : ''; }

  // init
  window.addEventListener('load', loadBooks);
  </script>
</body>
</html>